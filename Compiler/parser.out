Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    EXTERN

Grammar

Rule 0     S' -> pgm
Rule 1     pgm -> class_decl_list
Rule 2     class_decl_list -> class_decl class_decl_list
Rule 3     class_decl_list -> <empty>
Rule 4     class_decl -> class_decl_head LBRACE class_body_decl_list RBRACE
Rule 5     class_decl -> class_decl_head LBRACE error RBRACE
Rule 6     class_decl_head -> CLASS ID extends
Rule 7     extends -> EXTENDS ID
Rule 8     extends -> <empty>
Rule 9     class_body_decl_list -> class_body_decl_list class_body_decl
Rule 10    class_body_decl_list -> class_body_decl
Rule 11    class_body_decl -> field_decl
Rule 12    class_body_decl -> method_decl
Rule 13    class_body_decl -> constructor_decl
Rule 14    field_decl -> mod var_decl
Rule 15    method_decl -> method_header LPAREN param_list_opt RPAREN block
Rule 16    method_header -> mod VOID ID
Rule 17    method_header -> mod type ID
Rule 18    constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block
Rule 19    constructor_header -> mod ID
Rule 20    mod -> visibility_mod storage_mod
Rule 21    visibility_mod -> PUBLIC
Rule 22    visibility_mod -> PRIVATE
Rule 23    visibility_mod -> <empty>
Rule 24    storage_mod -> STATIC
Rule 25    storage_mod -> <empty>
Rule 26    var_decl -> type var_list SEMICOLON
Rule 27    type -> INT
Rule 28    type -> BOOLEAN
Rule 29    type -> FLOAT
Rule 30    type -> ID
Rule 31    var_list -> var_list COMMA var
Rule 32    var_list -> var
Rule 33    var -> ID dim_star
Rule 34    param_list_opt -> params_begin param_list params_end
Rule 35    param_list_opt -> params_end
Rule 36    param_list -> param_list COMMA param
Rule 37    param_list -> param
Rule 38    param -> type var
Rule 39    params_begin -> <empty>
Rule 40    params_end -> <empty>
Rule 41    block -> LBRACE block_begin stmt_list block_end RBRACE
Rule 42    block -> LBRACE block_begin stmt_list error block_end RBRACE
Rule 43    block_begin -> <empty>
Rule 44    block_end -> <empty>
Rule 45    stmt_list -> <empty>
Rule 46    stmt_list -> stmt_list stmt
Rule 47    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 48    stmt -> IF LPAREN expr RPAREN stmt
Rule 49    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 50    stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
Rule 51    stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON
Rule 52    stmt -> stmt_expr SEMICOLON
Rule 53    stmt -> BREAK SEMICOLON
Rule 54    stmt -> CONTINUE SEMICOLON
Rule 55    stmt -> block
Rule 56    stmt -> var_decl
Rule 57    stmt -> SEMICOLON
Rule 58    stmt -> error SEMICOLON
Rule 59    literal -> INT_CONST
Rule 60    literal -> FLOAT_CONST
Rule 61    literal -> STRING_CONST
Rule 62    literal -> NULL
Rule 63    literal -> TRUE
Rule 64    literal -> FALSE
Rule 65    primary -> literal
Rule 66    primary -> THIS
Rule 67    primary -> SUPER
Rule 68    primary -> LPAREN expr RPAREN
Rule 69    primary -> NEW ID LPAREN args_opt RPAREN
Rule 70    primary -> lhs
Rule 71    primary -> method_invocation
Rule 72    args_opt -> arg_plus
Rule 73    args_opt -> <empty>
Rule 74    arg_plus -> arg_plus COMMA expr
Rule 75    arg_plus -> expr
Rule 76    lhs -> field_access
Rule 77    lhs -> array_access
Rule 78    field_access -> primary DOT ID
Rule 79    field_access -> ID
Rule 80    array_access -> primary LBRACKET expr RBRACKET
Rule 81    method_invocation -> field_access LPAREN args_opt RPAREN
Rule 82    expr -> primary
Rule 83    expr -> assign
Rule 84    expr -> new_array
Rule 85    expr -> expr PLUS expr
Rule 86    expr -> expr REMAIN expr
Rule 87    expr -> expr MINUS expr
Rule 88    expr -> expr MULTIPLY expr
Rule 89    expr -> expr DIVIDE expr
Rule 90    expr -> expr EQ expr
Rule 91    expr -> expr NEQ expr
Rule 92    expr -> expr LT expr
Rule 93    expr -> expr LEQ expr
Rule 94    expr -> expr GT expr
Rule 95    expr -> expr GEQ expr
Rule 96    expr -> expr AND expr
Rule 97    expr -> expr OR expr
Rule 98    expr -> PLUS expr
Rule 99    expr -> MINUS expr
Rule 100   expr -> NOT expr
Rule 101   assign -> lhs ASSIGN expr
Rule 102   assign -> lhs INC
Rule 103   assign -> INC lhs
Rule 104   assign -> lhs DEC
Rule 105   assign -> DEC lhs
Rule 106   new_array -> NEW type dim_expr_plus dim_star
Rule 107   dim_expr_plus -> dim_expr_plus dim_expr
Rule 108   dim_expr_plus -> dim_expr
Rule 109   dim_expr -> LBRACKET expr RBRACKET
Rule 110   dim_star -> LBRACKET RBRACKET dim_star
Rule 111   dim_star -> <empty>
Rule 112   stmt_expr -> assign
Rule 113   stmt_expr -> method_invocation
Rule 114   stmt_expr_opt -> stmt_expr
Rule 115   stmt_expr_opt -> <empty>
Rule 116   expr_opt -> expr
Rule 117   expr_opt -> <empty>

Terminals, with rules where they appear

AND                  : 96
ASSIGN               : 101
BOOLEAN              : 28
BREAK                : 53
CLASS                : 6
COMMA                : 31 36 74
CONTINUE             : 54
DEC                  : 104 105
DIVIDE               : 89
DOT                  : 78
ELSE                 : 47
EQ                   : 90
EXTENDS              : 7
EXTERN               : 
FALSE                : 64
FLOAT                : 29
FLOAT_CONST          : 60
FOR                  : 50
GEQ                  : 95
GT                   : 94
ID                   : 6 7 16 17 19 30 33 69 78 79
IF                   : 47 48
INC                  : 102 103
INT                  : 27
INT_CONST            : 59
LBRACE               : 4 5 41 42
LBRACKET             : 80 109 110
LEQ                  : 93
LPAREN               : 15 18 47 48 49 50 51 68 69 81
LT                   : 92
MINUS                : 87 99
MULTIPLY             : 88
NEQ                  : 91
NEW                  : 69 106
NOT                  : 100
NULL                 : 62
OR                   : 97
PLUS                 : 85 98
PRIVATE              : 22
PUBLIC               : 21
RBRACE               : 4 5 41 42
RBRACKET             : 80 109 110
REMAIN               : 86
RETURN               : 51
RPAREN               : 15 18 47 48 49 50 51 68 69 81
SEMICOLON            : 26 50 50 51 52 53 54 57 58
STATIC               : 24
STRING_CONST         : 61
SUPER                : 67
THIS                 : 66
TRUE                 : 63
VOID                 : 16
WHILE                : 49
error                : 5 42 58

Nonterminals, with rules where they appear

arg_plus             : 72 74
args_opt             : 69 81
array_access         : 77
assign               : 83 112
block                : 15 18 55
block_begin          : 41 42
block_end            : 41 42
class_body_decl      : 9 10
class_body_decl_list : 4 9
class_decl           : 2
class_decl_head      : 4 5
class_decl_list      : 1 2
constructor_decl     : 13
constructor_header   : 18
dim_expr             : 107 108
dim_expr_plus        : 106 107
dim_star             : 33 106 110
expr                 : 47 48 49 68 74 75 80 85 85 86 86 87 87 88 88 89 89 90 90 91 91 92 92 93 93 94 94 95 95 96 96 97 97 98 99 100 101 109 116
expr_opt             : 50 51
extends              : 6
field_access         : 76 81
field_decl           : 11
lhs                  : 70 101 102 103 104 105
literal              : 65
method_decl          : 12
method_header        : 15
method_invocation    : 71 113
mod                  : 14 16 17 19
new_array            : 84
param                : 36 37
param_list           : 34 36
param_list_opt       : 15 18
params_begin         : 34
params_end           : 34 35
pgm                  : 0
primary              : 78 80 82
stmt                 : 46 47 47 48 49 50
stmt_expr            : 52 114
stmt_expr_opt        : 50 50
stmt_list            : 41 42 46
storage_mod          : 20
type                 : 17 26 38 106
var                  : 31 32 38
var_decl             : 14 56
var_list             : 26 31
visibility_mod       : 20

Parsing method: LALR

state 0

    (0) S' -> . pgm
    (1) pgm -> . class_decl_list
    (2) class_decl_list -> . class_decl class_decl_list
    (3) class_decl_list -> .
    (4) class_decl -> . class_decl_head LBRACE class_body_decl_list RBRACE
    (5) class_decl -> . class_decl_head LBRACE error RBRACE
    (6) class_decl_head -> . CLASS ID extends

    $end            reduce using rule 3 (class_decl_list -> .)
    CLASS           shift and go to state 5

    pgm                            shift and go to state 1
    class_decl_list                shift and go to state 2
    class_decl                     shift and go to state 3
    class_decl_head                shift and go to state 4

state 1

    (0) S' -> pgm .



state 2

    (1) pgm -> class_decl_list .

    $end            reduce using rule 1 (pgm -> class_decl_list .)


state 3

    (2) class_decl_list -> class_decl . class_decl_list
    (2) class_decl_list -> . class_decl class_decl_list
    (3) class_decl_list -> .
    (4) class_decl -> . class_decl_head LBRACE class_body_decl_list RBRACE
    (5) class_decl -> . class_decl_head LBRACE error RBRACE
    (6) class_decl_head -> . CLASS ID extends

    $end            reduce using rule 3 (class_decl_list -> .)
    CLASS           shift and go to state 5

    class_decl                     shift and go to state 3
    class_decl_list                shift and go to state 6
    class_decl_head                shift and go to state 4

state 4

    (4) class_decl -> class_decl_head . LBRACE class_body_decl_list RBRACE
    (5) class_decl -> class_decl_head . LBRACE error RBRACE

    LBRACE          shift and go to state 7


state 5

    (6) class_decl_head -> CLASS . ID extends

    ID              shift and go to state 8


state 6

    (2) class_decl_list -> class_decl class_decl_list .

    $end            reduce using rule 2 (class_decl_list -> class_decl class_decl_list .)


state 7

    (4) class_decl -> class_decl_head LBRACE . class_body_decl_list RBRACE
    (5) class_decl -> class_decl_head LBRACE . error RBRACE
    (9) class_body_decl_list -> . class_body_decl_list class_body_decl
    (10) class_body_decl_list -> . class_body_decl
    (11) class_body_decl -> . field_decl
    (12) class_body_decl -> . method_decl
    (13) class_body_decl -> . constructor_decl
    (14) field_decl -> . mod var_decl
    (15) method_decl -> . method_header LPAREN param_list_opt RPAREN block
    (18) constructor_decl -> . constructor_header LPAREN param_list_opt RPAREN block
    (20) mod -> . visibility_mod storage_mod
    (16) method_header -> . mod VOID ID
    (17) method_header -> . mod type ID
    (19) constructor_header -> . mod ID
    (21) visibility_mod -> . PUBLIC
    (22) visibility_mod -> . PRIVATE
    (23) visibility_mod -> .

    error           shift and go to state 10
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          reduce using rule 23 (visibility_mod -> .)
    VOID            reduce using rule 23 (visibility_mod -> .)
    ID              reduce using rule 23 (visibility_mod -> .)
    INT             reduce using rule 23 (visibility_mod -> .)
    BOOLEAN         reduce using rule 23 (visibility_mod -> .)
    FLOAT           reduce using rule 23 (visibility_mod -> .)

    class_body_decl_list           shift and go to state 9
    class_body_decl                shift and go to state 11
    field_decl                     shift and go to state 12
    method_decl                    shift and go to state 13
    constructor_decl               shift and go to state 14
    mod                            shift and go to state 15
    method_header                  shift and go to state 16
    constructor_header             shift and go to state 17
    visibility_mod                 shift and go to state 18

state 8

    (6) class_decl_head -> CLASS ID . extends
    (7) extends -> . EXTENDS ID
    (8) extends -> .

    EXTENDS         shift and go to state 22
    LBRACE          reduce using rule 8 (extends -> .)

    extends                        shift and go to state 21

state 9

    (4) class_decl -> class_decl_head LBRACE class_body_decl_list . RBRACE
    (9) class_body_decl_list -> class_body_decl_list . class_body_decl
    (11) class_body_decl -> . field_decl
    (12) class_body_decl -> . method_decl
    (13) class_body_decl -> . constructor_decl
    (14) field_decl -> . mod var_decl
    (15) method_decl -> . method_header LPAREN param_list_opt RPAREN block
    (18) constructor_decl -> . constructor_header LPAREN param_list_opt RPAREN block
    (20) mod -> . visibility_mod storage_mod
    (16) method_header -> . mod VOID ID
    (17) method_header -> . mod type ID
    (19) constructor_header -> . mod ID
    (21) visibility_mod -> . PUBLIC
    (22) visibility_mod -> . PRIVATE
    (23) visibility_mod -> .

    RBRACE          shift and go to state 23
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          reduce using rule 23 (visibility_mod -> .)
    VOID            reduce using rule 23 (visibility_mod -> .)
    ID              reduce using rule 23 (visibility_mod -> .)
    INT             reduce using rule 23 (visibility_mod -> .)
    BOOLEAN         reduce using rule 23 (visibility_mod -> .)
    FLOAT           reduce using rule 23 (visibility_mod -> .)

    class_body_decl                shift and go to state 24
    field_decl                     shift and go to state 12
    method_decl                    shift and go to state 13
    constructor_decl               shift and go to state 14
    mod                            shift and go to state 15
    method_header                  shift and go to state 16
    constructor_header             shift and go to state 17
    visibility_mod                 shift and go to state 18

state 10

    (5) class_decl -> class_decl_head LBRACE error . RBRACE

    RBRACE          shift and go to state 25


state 11

    (10) class_body_decl_list -> class_body_decl .

    RBRACE          reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    PUBLIC          reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    VOID            reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    ID              reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    INT             reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    FLOAT           reduce using rule 10 (class_body_decl_list -> class_body_decl .)
    STATIC          reduce using rule 10 (class_body_decl_list -> class_body_decl .)


state 12

    (11) class_body_decl -> field_decl .

    RBRACE          reduce using rule 11 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 11 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> field_decl .)
    VOID            reduce using rule 11 (class_body_decl -> field_decl .)
    ID              reduce using rule 11 (class_body_decl -> field_decl .)
    INT             reduce using rule 11 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> field_decl .)


state 13

    (12) class_body_decl -> method_decl .

    RBRACE          reduce using rule 12 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 12 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 12 (class_body_decl -> method_decl .)
    VOID            reduce using rule 12 (class_body_decl -> method_decl .)
    ID              reduce using rule 12 (class_body_decl -> method_decl .)
    INT             reduce using rule 12 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 12 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 12 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 12 (class_body_decl -> method_decl .)


state 14

    (13) class_body_decl -> constructor_decl .

    RBRACE          reduce using rule 13 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 13 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 13 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 13 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 13 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 13 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 13 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 13 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 13 (class_body_decl -> constructor_decl .)


state 15

    (14) field_decl -> mod . var_decl
    (16) method_header -> mod . VOID ID
    (17) method_header -> mod . type ID
    (19) constructor_header -> mod . ID
    (26) var_decl -> . type var_list SEMICOLON
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID

    VOID            shift and go to state 27
    ID              shift and go to state 28
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32

    var_decl                       shift and go to state 26
    type                           shift and go to state 29

state 16

    (15) method_decl -> method_header . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 33


state 17

    (18) constructor_decl -> constructor_header . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 34


state 18

    (20) mod -> visibility_mod . storage_mod
    (24) storage_mod -> . STATIC
    (25) storage_mod -> .

    STATIC          shift and go to state 36
    VOID            reduce using rule 25 (storage_mod -> .)
    ID              reduce using rule 25 (storage_mod -> .)
    INT             reduce using rule 25 (storage_mod -> .)
    BOOLEAN         reduce using rule 25 (storage_mod -> .)
    FLOAT           reduce using rule 25 (storage_mod -> .)

    storage_mod                    shift and go to state 35

state 19

    (21) visibility_mod -> PUBLIC .

    STATIC          reduce using rule 21 (visibility_mod -> PUBLIC .)
    VOID            reduce using rule 21 (visibility_mod -> PUBLIC .)
    ID              reduce using rule 21 (visibility_mod -> PUBLIC .)
    INT             reduce using rule 21 (visibility_mod -> PUBLIC .)
    BOOLEAN         reduce using rule 21 (visibility_mod -> PUBLIC .)
    FLOAT           reduce using rule 21 (visibility_mod -> PUBLIC .)


state 20

    (22) visibility_mod -> PRIVATE .

    STATIC          reduce using rule 22 (visibility_mod -> PRIVATE .)
    VOID            reduce using rule 22 (visibility_mod -> PRIVATE .)
    ID              reduce using rule 22 (visibility_mod -> PRIVATE .)
    INT             reduce using rule 22 (visibility_mod -> PRIVATE .)
    BOOLEAN         reduce using rule 22 (visibility_mod -> PRIVATE .)
    FLOAT           reduce using rule 22 (visibility_mod -> PRIVATE .)


state 21

    (6) class_decl_head -> CLASS ID extends .

    LBRACE          reduce using rule 6 (class_decl_head -> CLASS ID extends .)


state 22

    (7) extends -> EXTENDS . ID

    ID              shift and go to state 37


state 23

    (4) class_decl -> class_decl_head LBRACE class_body_decl_list RBRACE .

    CLASS           reduce using rule 4 (class_decl -> class_decl_head LBRACE class_body_decl_list RBRACE .)
    $end            reduce using rule 4 (class_decl -> class_decl_head LBRACE class_body_decl_list RBRACE .)


state 24

    (9) class_body_decl_list -> class_body_decl_list class_body_decl .

    RBRACE          reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    VOID            reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    ID              reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    INT             reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    FLOAT           reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)
    STATIC          reduce using rule 9 (class_body_decl_list -> class_body_decl_list class_body_decl .)


state 25

    (5) class_decl -> class_decl_head LBRACE error RBRACE .

    CLASS           reduce using rule 5 (class_decl -> class_decl_head LBRACE error RBRACE .)
    $end            reduce using rule 5 (class_decl -> class_decl_head LBRACE error RBRACE .)


state 26

    (14) field_decl -> mod var_decl .

    RBRACE          reduce using rule 14 (field_decl -> mod var_decl .)
    PUBLIC          reduce using rule 14 (field_decl -> mod var_decl .)
    PRIVATE         reduce using rule 14 (field_decl -> mod var_decl .)
    VOID            reduce using rule 14 (field_decl -> mod var_decl .)
    ID              reduce using rule 14 (field_decl -> mod var_decl .)
    INT             reduce using rule 14 (field_decl -> mod var_decl .)
    BOOLEAN         reduce using rule 14 (field_decl -> mod var_decl .)
    FLOAT           reduce using rule 14 (field_decl -> mod var_decl .)
    STATIC          reduce using rule 14 (field_decl -> mod var_decl .)


state 27

    (16) method_header -> mod VOID . ID

    ID              shift and go to state 38


state 28

    (19) constructor_header -> mod ID .
    (30) type -> ID .

    LPAREN          reduce using rule 19 (constructor_header -> mod ID .)
    ID              reduce using rule 30 (type -> ID .)


state 29

    (17) method_header -> mod type . ID
    (26) var_decl -> type . var_list SEMICOLON
    (31) var_list -> . var_list COMMA var
    (32) var_list -> . var
    (33) var -> . ID dim_star

    ID              shift and go to state 39

    var_list                       shift and go to state 40
    var                            shift and go to state 41

state 30

    (27) type -> INT .

    ID              reduce using rule 27 (type -> INT .)
    LBRACKET        reduce using rule 27 (type -> INT .)


state 31

    (28) type -> BOOLEAN .

    ID              reduce using rule 28 (type -> BOOLEAN .)
    LBRACKET        reduce using rule 28 (type -> BOOLEAN .)


state 32

    (29) type -> FLOAT .

    ID              reduce using rule 29 (type -> FLOAT .)
    LBRACKET        reduce using rule 29 (type -> FLOAT .)


state 33

    (15) method_decl -> method_header LPAREN . param_list_opt RPAREN block
    (34) param_list_opt -> . params_begin param_list params_end
    (35) param_list_opt -> . params_end
    (39) params_begin -> .
    (40) params_end -> .

    INT             reduce using rule 39 (params_begin -> .)
    BOOLEAN         reduce using rule 39 (params_begin -> .)
    FLOAT           reduce using rule 39 (params_begin -> .)
    ID              reduce using rule 39 (params_begin -> .)
    RPAREN          reduce using rule 40 (params_end -> .)

    param_list_opt                 shift and go to state 42
    params_begin                   shift and go to state 43
    params_end                     shift and go to state 44

state 34

    (18) constructor_decl -> constructor_header LPAREN . param_list_opt RPAREN block
    (34) param_list_opt -> . params_begin param_list params_end
    (35) param_list_opt -> . params_end
    (39) params_begin -> .
    (40) params_end -> .

    INT             reduce using rule 39 (params_begin -> .)
    BOOLEAN         reduce using rule 39 (params_begin -> .)
    FLOAT           reduce using rule 39 (params_begin -> .)
    ID              reduce using rule 39 (params_begin -> .)
    RPAREN          reduce using rule 40 (params_end -> .)

    param_list_opt                 shift and go to state 45
    params_begin                   shift and go to state 43
    params_end                     shift and go to state 44

state 35

    (20) mod -> visibility_mod storage_mod .

    VOID            reduce using rule 20 (mod -> visibility_mod storage_mod .)
    ID              reduce using rule 20 (mod -> visibility_mod storage_mod .)
    INT             reduce using rule 20 (mod -> visibility_mod storage_mod .)
    BOOLEAN         reduce using rule 20 (mod -> visibility_mod storage_mod .)
    FLOAT           reduce using rule 20 (mod -> visibility_mod storage_mod .)


state 36

    (24) storage_mod -> STATIC .

    VOID            reduce using rule 24 (storage_mod -> STATIC .)
    ID              reduce using rule 24 (storage_mod -> STATIC .)
    INT             reduce using rule 24 (storage_mod -> STATIC .)
    BOOLEAN         reduce using rule 24 (storage_mod -> STATIC .)
    FLOAT           reduce using rule 24 (storage_mod -> STATIC .)


state 37

    (7) extends -> EXTENDS ID .

    LBRACE          reduce using rule 7 (extends -> EXTENDS ID .)


state 38

    (16) method_header -> mod VOID ID .

    LPAREN          reduce using rule 16 (method_header -> mod VOID ID .)


state 39

    (17) method_header -> mod type ID .
    (33) var -> ID . dim_star
    (110) dim_star -> . LBRACKET RBRACKET dim_star
    (111) dim_star -> .

    LPAREN          reduce using rule 17 (method_header -> mod type ID .)
    LBRACKET        shift and go to state 47
    SEMICOLON       reduce using rule 111 (dim_star -> .)
    COMMA           reduce using rule 111 (dim_star -> .)

    dim_star                       shift and go to state 46

state 40

    (26) var_decl -> type var_list . SEMICOLON
    (31) var_list -> var_list . COMMA var

    SEMICOLON       shift and go to state 48
    COMMA           shift and go to state 49


state 41

    (32) var_list -> var .

    SEMICOLON       reduce using rule 32 (var_list -> var .)
    COMMA           reduce using rule 32 (var_list -> var .)


state 42

    (15) method_decl -> method_header LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 50


state 43

    (34) param_list_opt -> params_begin . param_list params_end
    (36) param_list -> . param_list COMMA param
    (37) param_list -> . param
    (38) param -> . type var
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID

    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 54

    param_list                     shift and go to state 51
    param                          shift and go to state 52
    type                           shift and go to state 53

state 44

    (35) param_list_opt -> params_end .

    RPAREN          reduce using rule 35 (param_list_opt -> params_end .)


state 45

    (18) constructor_decl -> constructor_header LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 55


state 46

    (33) var -> ID dim_star .

    SEMICOLON       reduce using rule 33 (var -> ID dim_star .)
    COMMA           reduce using rule 33 (var -> ID dim_star .)
    RPAREN          reduce using rule 33 (var -> ID dim_star .)


state 47

    (110) dim_star -> LBRACKET . RBRACKET dim_star

    RBRACKET        shift and go to state 56


state 48

    (26) var_decl -> type var_list SEMICOLON .

    RBRACE          reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    PUBLIC          reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    PRIVATE         reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    VOID            reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    ID              reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    INT             reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    BOOLEAN         reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    FLOAT           reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    STATIC          reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    error           reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    IF              reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    WHILE           reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    FOR             reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    RETURN          reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    BREAK           reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    CONTINUE        reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    SEMICOLON       reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    LBRACE          reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    INC             reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    DEC             reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    THIS            reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    SUPER           reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    LPAREN          reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    NEW             reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    INT_CONST       reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    FLOAT_CONST     reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    STRING_CONST    reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    NULL            reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    TRUE            reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    FALSE           reduce using rule 26 (var_decl -> type var_list SEMICOLON .)
    ELSE            reduce using rule 26 (var_decl -> type var_list SEMICOLON .)


state 49

    (31) var_list -> var_list COMMA . var
    (33) var -> . ID dim_star

    ID              shift and go to state 58

    var                            shift and go to state 57

state 50

    (15) method_decl -> method_header LPAREN param_list_opt RPAREN . block
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE

    LBRACE          shift and go to state 60

    block                          shift and go to state 59

state 51

    (34) param_list_opt -> params_begin param_list . params_end
    (36) param_list -> param_list . COMMA param
    (40) params_end -> .

    COMMA           shift and go to state 62
    RPAREN          reduce using rule 40 (params_end -> .)

    params_end                     shift and go to state 61

state 52

    (37) param_list -> param .

    COMMA           reduce using rule 37 (param_list -> param .)
    RPAREN          reduce using rule 37 (param_list -> param .)


state 53

    (38) param -> type . var
    (33) var -> . ID dim_star

    ID              shift and go to state 58

    var                            shift and go to state 63

state 54

    (30) type -> ID .

    ID              reduce using rule 30 (type -> ID .)


state 55

    (18) constructor_decl -> constructor_header LPAREN param_list_opt RPAREN . block
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE

    LBRACE          shift and go to state 60

    block                          shift and go to state 64

state 56

    (110) dim_star -> LBRACKET RBRACKET . dim_star
    (110) dim_star -> . LBRACKET RBRACKET dim_star
    (111) dim_star -> .

    LBRACKET        shift and go to state 47
    SEMICOLON       reduce using rule 111 (dim_star -> .)
    COMMA           reduce using rule 111 (dim_star -> .)
    RPAREN          reduce using rule 111 (dim_star -> .)
    PLUS            reduce using rule 111 (dim_star -> .)
    REMAIN          reduce using rule 111 (dim_star -> .)
    MINUS           reduce using rule 111 (dim_star -> .)
    MULTIPLY        reduce using rule 111 (dim_star -> .)
    DIVIDE          reduce using rule 111 (dim_star -> .)
    EQ              reduce using rule 111 (dim_star -> .)
    NEQ             reduce using rule 111 (dim_star -> .)
    LT              reduce using rule 111 (dim_star -> .)
    LEQ             reduce using rule 111 (dim_star -> .)
    GT              reduce using rule 111 (dim_star -> .)
    GEQ             reduce using rule 111 (dim_star -> .)
    AND             reduce using rule 111 (dim_star -> .)
    OR              reduce using rule 111 (dim_star -> .)
    RBRACKET        reduce using rule 111 (dim_star -> .)

    dim_star                       shift and go to state 65

state 57

    (31) var_list -> var_list COMMA var .

    SEMICOLON       reduce using rule 31 (var_list -> var_list COMMA var .)
    COMMA           reduce using rule 31 (var_list -> var_list COMMA var .)


state 58

    (33) var -> ID . dim_star
    (110) dim_star -> . LBRACKET RBRACKET dim_star
    (111) dim_star -> .

    LBRACKET        shift and go to state 47
    SEMICOLON       reduce using rule 111 (dim_star -> .)
    COMMA           reduce using rule 111 (dim_star -> .)
    RPAREN          reduce using rule 111 (dim_star -> .)

    dim_star                       shift and go to state 46

state 59

    (15) method_decl -> method_header LPAREN param_list_opt RPAREN block .

    RBRACE          reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    PUBLIC          reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    PRIVATE         reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    VOID            reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    BOOLEAN         reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)
    STATIC          reduce using rule 15 (method_decl -> method_header LPAREN param_list_opt RPAREN block .)


state 60

    (41) block -> LBRACE . block_begin stmt_list block_end RBRACE
    (42) block -> LBRACE . block_begin stmt_list error block_end RBRACE
    (43) block_begin -> .

    error           reduce using rule 43 (block_begin -> .)
    IF              reduce using rule 43 (block_begin -> .)
    WHILE           reduce using rule 43 (block_begin -> .)
    FOR             reduce using rule 43 (block_begin -> .)
    RETURN          reduce using rule 43 (block_begin -> .)
    BREAK           reduce using rule 43 (block_begin -> .)
    CONTINUE        reduce using rule 43 (block_begin -> .)
    SEMICOLON       reduce using rule 43 (block_begin -> .)
    LBRACE          reduce using rule 43 (block_begin -> .)
    INC             reduce using rule 43 (block_begin -> .)
    DEC             reduce using rule 43 (block_begin -> .)
    INT             reduce using rule 43 (block_begin -> .)
    BOOLEAN         reduce using rule 43 (block_begin -> .)
    FLOAT           reduce using rule 43 (block_begin -> .)
    ID              reduce using rule 43 (block_begin -> .)
    THIS            reduce using rule 43 (block_begin -> .)
    SUPER           reduce using rule 43 (block_begin -> .)
    LPAREN          reduce using rule 43 (block_begin -> .)
    NEW             reduce using rule 43 (block_begin -> .)
    INT_CONST       reduce using rule 43 (block_begin -> .)
    FLOAT_CONST     reduce using rule 43 (block_begin -> .)
    STRING_CONST    reduce using rule 43 (block_begin -> .)
    NULL            reduce using rule 43 (block_begin -> .)
    TRUE            reduce using rule 43 (block_begin -> .)
    FALSE           reduce using rule 43 (block_begin -> .)
    RBRACE          reduce using rule 43 (block_begin -> .)

    block_begin                    shift and go to state 66

state 61

    (34) param_list_opt -> params_begin param_list params_end .

    RPAREN          reduce using rule 34 (param_list_opt -> params_begin param_list params_end .)


state 62

    (36) param_list -> param_list COMMA . param
    (38) param -> . type var
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID

    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 54

    param                          shift and go to state 67
    type                           shift and go to state 53

state 63

    (38) param -> type var .

    COMMA           reduce using rule 38 (param -> type var .)
    RPAREN          reduce using rule 38 (param -> type var .)


state 64

    (18) constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .

    RBRACE          reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    PUBLIC          reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    PRIVATE         reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    VOID            reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    BOOLEAN         reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)
    STATIC          reduce using rule 18 (constructor_decl -> constructor_header LPAREN param_list_opt RPAREN block .)


state 65

    (110) dim_star -> LBRACKET RBRACKET dim_star .

    SEMICOLON       reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    COMMA           reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    RPAREN          reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    PLUS            reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    REMAIN          reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    MINUS           reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    MULTIPLY        reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    DIVIDE          reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    EQ              reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    NEQ             reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    LT              reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    LEQ             reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    GT              reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    GEQ             reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    AND             reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    OR              reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)
    RBRACKET        reduce using rule 110 (dim_star -> LBRACKET RBRACKET dim_star .)


state 66

    (41) block -> LBRACE block_begin . stmt_list block_end RBRACE
    (42) block -> LBRACE block_begin . stmt_list error block_end RBRACE
    (45) stmt_list -> .
    (46) stmt_list -> . stmt_list stmt

    error           reduce using rule 45 (stmt_list -> .)
    IF              reduce using rule 45 (stmt_list -> .)
    WHILE           reduce using rule 45 (stmt_list -> .)
    FOR             reduce using rule 45 (stmt_list -> .)
    RETURN          reduce using rule 45 (stmt_list -> .)
    BREAK           reduce using rule 45 (stmt_list -> .)
    CONTINUE        reduce using rule 45 (stmt_list -> .)
    SEMICOLON       reduce using rule 45 (stmt_list -> .)
    LBRACE          reduce using rule 45 (stmt_list -> .)
    INC             reduce using rule 45 (stmt_list -> .)
    DEC             reduce using rule 45 (stmt_list -> .)
    INT             reduce using rule 45 (stmt_list -> .)
    BOOLEAN         reduce using rule 45 (stmt_list -> .)
    FLOAT           reduce using rule 45 (stmt_list -> .)
    ID              reduce using rule 45 (stmt_list -> .)
    THIS            reduce using rule 45 (stmt_list -> .)
    SUPER           reduce using rule 45 (stmt_list -> .)
    LPAREN          reduce using rule 45 (stmt_list -> .)
    NEW             reduce using rule 45 (stmt_list -> .)
    INT_CONST       reduce using rule 45 (stmt_list -> .)
    FLOAT_CONST     reduce using rule 45 (stmt_list -> .)
    STRING_CONST    reduce using rule 45 (stmt_list -> .)
    NULL            reduce using rule 45 (stmt_list -> .)
    TRUE            reduce using rule 45 (stmt_list -> .)
    FALSE           reduce using rule 45 (stmt_list -> .)
    RBRACE          reduce using rule 45 (stmt_list -> .)

    stmt_list                      shift and go to state 68

state 67

    (36) param_list -> param_list COMMA param .

    COMMA           reduce using rule 36 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 36 (param_list -> param_list COMMA param .)


state 68

    (41) block -> LBRACE block_begin stmt_list . block_end RBRACE
    (42) block -> LBRACE block_begin stmt_list . error block_end RBRACE
    (46) stmt_list -> stmt_list . stmt
    (44) block_end -> .
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . IF LPAREN expr RPAREN stmt
    (49) stmt -> . WHILE LPAREN expr RPAREN stmt
    (50) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (51) stmt -> . RETURN LPAREN expr_opt RPAREN SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (58) stmt -> . error SEMICOLON
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE
    (26) var_decl -> . type var_list SEMICOLON
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    error           shift and go to state 70
    RBRACE          reduce using rule 44 (block_end -> .)
    IF              shift and go to state 72
    WHILE           shift and go to state 74
    FOR             shift and go to state 75
    RETURN          shift and go to state 77
    BREAK           shift and go to state 79
    CONTINUE        shift and go to state 80
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 60
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 90
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    block_end                      shift and go to state 69
    stmt                           shift and go to state 71
    stmt_expr                      shift and go to state 78
    block                          shift and go to state 81
    var_decl                       shift and go to state 82
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    type                           shift and go to state 85
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 69

    (41) block -> LBRACE block_begin stmt_list block_end . RBRACE

    RBRACE          shift and go to state 103


state 70

    (42) block -> LBRACE block_begin stmt_list error . block_end RBRACE
    (58) stmt -> error . SEMICOLON
    (44) block_end -> .

    SEMICOLON       shift and go to state 105
    RBRACE          reduce using rule 44 (block_end -> .)

    block_end                      shift and go to state 104

state 71

    (46) stmt_list -> stmt_list stmt .

    error           reduce using rule 46 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 46 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 46 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 46 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 46 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 46 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 46 (stmt_list -> stmt_list stmt .)
    SEMICOLON       reduce using rule 46 (stmt_list -> stmt_list stmt .)
    LBRACE          reduce using rule 46 (stmt_list -> stmt_list stmt .)
    INC             reduce using rule 46 (stmt_list -> stmt_list stmt .)
    DEC             reduce using rule 46 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 46 (stmt_list -> stmt_list stmt .)
    BOOLEAN         reduce using rule 46 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 46 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 46 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 46 (stmt_list -> stmt_list stmt .)
    SUPER           reduce using rule 46 (stmt_list -> stmt_list stmt .)
    LPAREN          reduce using rule 46 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 46 (stmt_list -> stmt_list stmt .)
    INT_CONST       reduce using rule 46 (stmt_list -> stmt_list stmt .)
    FLOAT_CONST     reduce using rule 46 (stmt_list -> stmt_list stmt .)
    STRING_CONST    reduce using rule 46 (stmt_list -> stmt_list stmt .)
    NULL            reduce using rule 46 (stmt_list -> stmt_list stmt .)
    TRUE            reduce using rule 46 (stmt_list -> stmt_list stmt .)
    FALSE           reduce using rule 46 (stmt_list -> stmt_list stmt .)
    RBRACE          reduce using rule 46 (stmt_list -> stmt_list stmt .)


state 72

    (47) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> IF . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 106


state 73

    (68) primary -> LPAREN . expr RPAREN
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 107
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 74

    (49) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 119


state 75

    (50) stmt -> FOR . LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt

    LPAREN          shift and go to state 120


state 76

    (57) stmt -> SEMICOLON .

    error           reduce using rule 57 (stmt -> SEMICOLON .)
    IF              reduce using rule 57 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 57 (stmt -> SEMICOLON .)
    FOR             reduce using rule 57 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 57 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 57 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 57 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 57 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 57 (stmt -> SEMICOLON .)
    INC             reduce using rule 57 (stmt -> SEMICOLON .)
    DEC             reduce using rule 57 (stmt -> SEMICOLON .)
    INT             reduce using rule 57 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 57 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 57 (stmt -> SEMICOLON .)
    ID              reduce using rule 57 (stmt -> SEMICOLON .)
    THIS            reduce using rule 57 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 57 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 57 (stmt -> SEMICOLON .)
    NEW             reduce using rule 57 (stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 57 (stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 57 (stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 57 (stmt -> SEMICOLON .)
    NULL            reduce using rule 57 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 57 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 57 (stmt -> SEMICOLON .)
    RBRACE          reduce using rule 57 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 57 (stmt -> SEMICOLON .)


state 77

    (51) stmt -> RETURN . LPAREN expr_opt RPAREN SEMICOLON

    LPAREN          shift and go to state 121


state 78

    (52) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 122


state 79

    (53) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 123


state 80

    (54) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 124


state 81

    (55) stmt -> block .

    error           reduce using rule 55 (stmt -> block .)
    IF              reduce using rule 55 (stmt -> block .)
    WHILE           reduce using rule 55 (stmt -> block .)
    FOR             reduce using rule 55 (stmt -> block .)
    RETURN          reduce using rule 55 (stmt -> block .)
    BREAK           reduce using rule 55 (stmt -> block .)
    CONTINUE        reduce using rule 55 (stmt -> block .)
    SEMICOLON       reduce using rule 55 (stmt -> block .)
    LBRACE          reduce using rule 55 (stmt -> block .)
    INC             reduce using rule 55 (stmt -> block .)
    DEC             reduce using rule 55 (stmt -> block .)
    INT             reduce using rule 55 (stmt -> block .)
    BOOLEAN         reduce using rule 55 (stmt -> block .)
    FLOAT           reduce using rule 55 (stmt -> block .)
    ID              reduce using rule 55 (stmt -> block .)
    THIS            reduce using rule 55 (stmt -> block .)
    SUPER           reduce using rule 55 (stmt -> block .)
    LPAREN          reduce using rule 55 (stmt -> block .)
    NEW             reduce using rule 55 (stmt -> block .)
    INT_CONST       reduce using rule 55 (stmt -> block .)
    FLOAT_CONST     reduce using rule 55 (stmt -> block .)
    STRING_CONST    reduce using rule 55 (stmt -> block .)
    NULL            reduce using rule 55 (stmt -> block .)
    TRUE            reduce using rule 55 (stmt -> block .)
    FALSE           reduce using rule 55 (stmt -> block .)
    RBRACE          reduce using rule 55 (stmt -> block .)
    ELSE            reduce using rule 55 (stmt -> block .)


state 82

    (56) stmt -> var_decl .

    error           reduce using rule 56 (stmt -> var_decl .)
    IF              reduce using rule 56 (stmt -> var_decl .)
    WHILE           reduce using rule 56 (stmt -> var_decl .)
    FOR             reduce using rule 56 (stmt -> var_decl .)
    RETURN          reduce using rule 56 (stmt -> var_decl .)
    BREAK           reduce using rule 56 (stmt -> var_decl .)
    CONTINUE        reduce using rule 56 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 56 (stmt -> var_decl .)
    LBRACE          reduce using rule 56 (stmt -> var_decl .)
    INC             reduce using rule 56 (stmt -> var_decl .)
    DEC             reduce using rule 56 (stmt -> var_decl .)
    INT             reduce using rule 56 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 56 (stmt -> var_decl .)
    FLOAT           reduce using rule 56 (stmt -> var_decl .)
    ID              reduce using rule 56 (stmt -> var_decl .)
    THIS            reduce using rule 56 (stmt -> var_decl .)
    SUPER           reduce using rule 56 (stmt -> var_decl .)
    LPAREN          reduce using rule 56 (stmt -> var_decl .)
    NEW             reduce using rule 56 (stmt -> var_decl .)
    INT_CONST       reduce using rule 56 (stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 56 (stmt -> var_decl .)
    STRING_CONST    reduce using rule 56 (stmt -> var_decl .)
    NULL            reduce using rule 56 (stmt -> var_decl .)
    TRUE            reduce using rule 56 (stmt -> var_decl .)
    FALSE           reduce using rule 56 (stmt -> var_decl .)
    RBRACE          reduce using rule 56 (stmt -> var_decl .)
    ELSE            reduce using rule 56 (stmt -> var_decl .)


state 83

    (112) stmt_expr -> assign .

    SEMICOLON       reduce using rule 112 (stmt_expr -> assign .)
    RPAREN          reduce using rule 112 (stmt_expr -> assign .)


state 84

    (113) stmt_expr -> method_invocation .
    (71) primary -> method_invocation .

    SEMICOLON       reduce using rule 113 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 113 (stmt_expr -> method_invocation .)
    DOT             reduce using rule 71 (primary -> method_invocation .)
    LBRACKET        reduce using rule 71 (primary -> method_invocation .)


state 85

    (26) var_decl -> type . var_list SEMICOLON
    (31) var_list -> . var_list COMMA var
    (32) var_list -> . var
    (33) var -> . ID dim_star

    ID              shift and go to state 58

    var_list                       shift and go to state 40
    var                            shift and go to state 41

state 86

    (101) assign -> lhs . ASSIGN expr
    (102) assign -> lhs . INC
    (104) assign -> lhs . DEC
    (70) primary -> lhs .

    ASSIGN          shift and go to state 125
    INC             shift and go to state 126
    DEC             shift and go to state 127
    DOT             reduce using rule 70 (primary -> lhs .)
    LBRACKET        reduce using rule 70 (primary -> lhs .)


state 87

    (103) assign -> INC . lhs
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN

    ID              shift and go to state 115
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    lhs                            shift and go to state 128
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93
    method_invocation              shift and go to state 117

state 88

    (105) assign -> DEC . lhs
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN

    ID              shift and go to state 115
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    lhs                            shift and go to state 129
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93
    method_invocation              shift and go to state 117

state 89

    (81) method_invocation -> field_access . LPAREN args_opt RPAREN
    (76) lhs -> field_access .

    LPAREN          shift and go to state 130
    ASSIGN          reduce using rule 76 (lhs -> field_access .)
    INC             reduce using rule 76 (lhs -> field_access .)
    DEC             reduce using rule 76 (lhs -> field_access .)
    DOT             reduce using rule 76 (lhs -> field_access .)
    LBRACKET        reduce using rule 76 (lhs -> field_access .)


state 90

    (30) type -> ID .
    (79) field_access -> ID .

    ID              reduce using rule 30 (type -> ID .)
    LPAREN          reduce using rule 79 (field_access -> ID .)
    ASSIGN          reduce using rule 79 (field_access -> ID .)
    INC             reduce using rule 79 (field_access -> ID .)
    DEC             reduce using rule 79 (field_access -> ID .)
    DOT             reduce using rule 79 (field_access -> ID .)
    LBRACKET        reduce using rule 79 (field_access -> ID .)


state 91

    (77) lhs -> array_access .

    ASSIGN          reduce using rule 77 (lhs -> array_access .)
    INC             reduce using rule 77 (lhs -> array_access .)
    DEC             reduce using rule 77 (lhs -> array_access .)
    DOT             reduce using rule 77 (lhs -> array_access .)
    LBRACKET        reduce using rule 77 (lhs -> array_access .)
    RPAREN          reduce using rule 77 (lhs -> array_access .)
    PLUS            reduce using rule 77 (lhs -> array_access .)
    REMAIN          reduce using rule 77 (lhs -> array_access .)
    MINUS           reduce using rule 77 (lhs -> array_access .)
    MULTIPLY        reduce using rule 77 (lhs -> array_access .)
    DIVIDE          reduce using rule 77 (lhs -> array_access .)
    EQ              reduce using rule 77 (lhs -> array_access .)
    NEQ             reduce using rule 77 (lhs -> array_access .)
    LT              reduce using rule 77 (lhs -> array_access .)
    LEQ             reduce using rule 77 (lhs -> array_access .)
    GT              reduce using rule 77 (lhs -> array_access .)
    GEQ             reduce using rule 77 (lhs -> array_access .)
    AND             reduce using rule 77 (lhs -> array_access .)
    OR              reduce using rule 77 (lhs -> array_access .)
    SEMICOLON       reduce using rule 77 (lhs -> array_access .)
    COMMA           reduce using rule 77 (lhs -> array_access .)
    RBRACKET        reduce using rule 77 (lhs -> array_access .)


state 92

    (78) field_access -> primary . DOT ID
    (80) array_access -> primary . LBRACKET expr RBRACKET

    DOT             shift and go to state 131
    LBRACKET        shift and go to state 132


state 93

    (65) primary -> literal .

    DOT             reduce using rule 65 (primary -> literal .)
    LBRACKET        reduce using rule 65 (primary -> literal .)
    RPAREN          reduce using rule 65 (primary -> literal .)
    PLUS            reduce using rule 65 (primary -> literal .)
    REMAIN          reduce using rule 65 (primary -> literal .)
    MINUS           reduce using rule 65 (primary -> literal .)
    MULTIPLY        reduce using rule 65 (primary -> literal .)
    DIVIDE          reduce using rule 65 (primary -> literal .)
    EQ              reduce using rule 65 (primary -> literal .)
    NEQ             reduce using rule 65 (primary -> literal .)
    LT              reduce using rule 65 (primary -> literal .)
    LEQ             reduce using rule 65 (primary -> literal .)
    GT              reduce using rule 65 (primary -> literal .)
    GEQ             reduce using rule 65 (primary -> literal .)
    AND             reduce using rule 65 (primary -> literal .)
    OR              reduce using rule 65 (primary -> literal .)
    SEMICOLON       reduce using rule 65 (primary -> literal .)
    COMMA           reduce using rule 65 (primary -> literal .)
    RBRACKET        reduce using rule 65 (primary -> literal .)


state 94

    (66) primary -> THIS .

    DOT             reduce using rule 66 (primary -> THIS .)
    LBRACKET        reduce using rule 66 (primary -> THIS .)
    RPAREN          reduce using rule 66 (primary -> THIS .)
    PLUS            reduce using rule 66 (primary -> THIS .)
    REMAIN          reduce using rule 66 (primary -> THIS .)
    MINUS           reduce using rule 66 (primary -> THIS .)
    MULTIPLY        reduce using rule 66 (primary -> THIS .)
    DIVIDE          reduce using rule 66 (primary -> THIS .)
    EQ              reduce using rule 66 (primary -> THIS .)
    NEQ             reduce using rule 66 (primary -> THIS .)
    LT              reduce using rule 66 (primary -> THIS .)
    LEQ             reduce using rule 66 (primary -> THIS .)
    GT              reduce using rule 66 (primary -> THIS .)
    GEQ             reduce using rule 66 (primary -> THIS .)
    AND             reduce using rule 66 (primary -> THIS .)
    OR              reduce using rule 66 (primary -> THIS .)
    SEMICOLON       reduce using rule 66 (primary -> THIS .)
    COMMA           reduce using rule 66 (primary -> THIS .)
    RBRACKET        reduce using rule 66 (primary -> THIS .)


state 95

    (67) primary -> SUPER .

    DOT             reduce using rule 67 (primary -> SUPER .)
    LBRACKET        reduce using rule 67 (primary -> SUPER .)
    RPAREN          reduce using rule 67 (primary -> SUPER .)
    PLUS            reduce using rule 67 (primary -> SUPER .)
    REMAIN          reduce using rule 67 (primary -> SUPER .)
    MINUS           reduce using rule 67 (primary -> SUPER .)
    MULTIPLY        reduce using rule 67 (primary -> SUPER .)
    DIVIDE          reduce using rule 67 (primary -> SUPER .)
    EQ              reduce using rule 67 (primary -> SUPER .)
    NEQ             reduce using rule 67 (primary -> SUPER .)
    LT              reduce using rule 67 (primary -> SUPER .)
    LEQ             reduce using rule 67 (primary -> SUPER .)
    GT              reduce using rule 67 (primary -> SUPER .)
    GEQ             reduce using rule 67 (primary -> SUPER .)
    AND             reduce using rule 67 (primary -> SUPER .)
    OR              reduce using rule 67 (primary -> SUPER .)
    SEMICOLON       reduce using rule 67 (primary -> SUPER .)
    COMMA           reduce using rule 67 (primary -> SUPER .)
    RBRACKET        reduce using rule 67 (primary -> SUPER .)


state 96

    (69) primary -> NEW . ID LPAREN args_opt RPAREN

    ID              shift and go to state 133


state 97

    (59) literal -> INT_CONST .

    DOT             reduce using rule 59 (literal -> INT_CONST .)
    LBRACKET        reduce using rule 59 (literal -> INT_CONST .)
    RPAREN          reduce using rule 59 (literal -> INT_CONST .)
    PLUS            reduce using rule 59 (literal -> INT_CONST .)
    REMAIN          reduce using rule 59 (literal -> INT_CONST .)
    MINUS           reduce using rule 59 (literal -> INT_CONST .)
    MULTIPLY        reduce using rule 59 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 59 (literal -> INT_CONST .)
    EQ              reduce using rule 59 (literal -> INT_CONST .)
    NEQ             reduce using rule 59 (literal -> INT_CONST .)
    LT              reduce using rule 59 (literal -> INT_CONST .)
    LEQ             reduce using rule 59 (literal -> INT_CONST .)
    GT              reduce using rule 59 (literal -> INT_CONST .)
    GEQ             reduce using rule 59 (literal -> INT_CONST .)
    AND             reduce using rule 59 (literal -> INT_CONST .)
    OR              reduce using rule 59 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 59 (literal -> INT_CONST .)
    COMMA           reduce using rule 59 (literal -> INT_CONST .)
    RBRACKET        reduce using rule 59 (literal -> INT_CONST .)


state 98

    (60) literal -> FLOAT_CONST .

    DOT             reduce using rule 60 (literal -> FLOAT_CONST .)
    LBRACKET        reduce using rule 60 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 60 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 60 (literal -> FLOAT_CONST .)
    REMAIN          reduce using rule 60 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 60 (literal -> FLOAT_CONST .)
    MULTIPLY        reduce using rule 60 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 60 (literal -> FLOAT_CONST .)
    EQ              reduce using rule 60 (literal -> FLOAT_CONST .)
    NEQ             reduce using rule 60 (literal -> FLOAT_CONST .)
    LT              reduce using rule 60 (literal -> FLOAT_CONST .)
    LEQ             reduce using rule 60 (literal -> FLOAT_CONST .)
    GT              reduce using rule 60 (literal -> FLOAT_CONST .)
    GEQ             reduce using rule 60 (literal -> FLOAT_CONST .)
    AND             reduce using rule 60 (literal -> FLOAT_CONST .)
    OR              reduce using rule 60 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 60 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 60 (literal -> FLOAT_CONST .)
    RBRACKET        reduce using rule 60 (literal -> FLOAT_CONST .)


state 99

    (61) literal -> STRING_CONST .

    DOT             reduce using rule 61 (literal -> STRING_CONST .)
    LBRACKET        reduce using rule 61 (literal -> STRING_CONST .)
    RPAREN          reduce using rule 61 (literal -> STRING_CONST .)
    PLUS            reduce using rule 61 (literal -> STRING_CONST .)
    REMAIN          reduce using rule 61 (literal -> STRING_CONST .)
    MINUS           reduce using rule 61 (literal -> STRING_CONST .)
    MULTIPLY        reduce using rule 61 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 61 (literal -> STRING_CONST .)
    EQ              reduce using rule 61 (literal -> STRING_CONST .)
    NEQ             reduce using rule 61 (literal -> STRING_CONST .)
    LT              reduce using rule 61 (literal -> STRING_CONST .)
    LEQ             reduce using rule 61 (literal -> STRING_CONST .)
    GT              reduce using rule 61 (literal -> STRING_CONST .)
    GEQ             reduce using rule 61 (literal -> STRING_CONST .)
    AND             reduce using rule 61 (literal -> STRING_CONST .)
    OR              reduce using rule 61 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 61 (literal -> STRING_CONST .)
    COMMA           reduce using rule 61 (literal -> STRING_CONST .)
    RBRACKET        reduce using rule 61 (literal -> STRING_CONST .)


state 100

    (62) literal -> NULL .

    DOT             reduce using rule 62 (literal -> NULL .)
    LBRACKET        reduce using rule 62 (literal -> NULL .)
    RPAREN          reduce using rule 62 (literal -> NULL .)
    PLUS            reduce using rule 62 (literal -> NULL .)
    REMAIN          reduce using rule 62 (literal -> NULL .)
    MINUS           reduce using rule 62 (literal -> NULL .)
    MULTIPLY        reduce using rule 62 (literal -> NULL .)
    DIVIDE          reduce using rule 62 (literal -> NULL .)
    EQ              reduce using rule 62 (literal -> NULL .)
    NEQ             reduce using rule 62 (literal -> NULL .)
    LT              reduce using rule 62 (literal -> NULL .)
    LEQ             reduce using rule 62 (literal -> NULL .)
    GT              reduce using rule 62 (literal -> NULL .)
    GEQ             reduce using rule 62 (literal -> NULL .)
    AND             reduce using rule 62 (literal -> NULL .)
    OR              reduce using rule 62 (literal -> NULL .)
    SEMICOLON       reduce using rule 62 (literal -> NULL .)
    COMMA           reduce using rule 62 (literal -> NULL .)
    RBRACKET        reduce using rule 62 (literal -> NULL .)


state 101

    (63) literal -> TRUE .

    DOT             reduce using rule 63 (literal -> TRUE .)
    LBRACKET        reduce using rule 63 (literal -> TRUE .)
    RPAREN          reduce using rule 63 (literal -> TRUE .)
    PLUS            reduce using rule 63 (literal -> TRUE .)
    REMAIN          reduce using rule 63 (literal -> TRUE .)
    MINUS           reduce using rule 63 (literal -> TRUE .)
    MULTIPLY        reduce using rule 63 (literal -> TRUE .)
    DIVIDE          reduce using rule 63 (literal -> TRUE .)
    EQ              reduce using rule 63 (literal -> TRUE .)
    NEQ             reduce using rule 63 (literal -> TRUE .)
    LT              reduce using rule 63 (literal -> TRUE .)
    LEQ             reduce using rule 63 (literal -> TRUE .)
    GT              reduce using rule 63 (literal -> TRUE .)
    GEQ             reduce using rule 63 (literal -> TRUE .)
    AND             reduce using rule 63 (literal -> TRUE .)
    OR              reduce using rule 63 (literal -> TRUE .)
    SEMICOLON       reduce using rule 63 (literal -> TRUE .)
    COMMA           reduce using rule 63 (literal -> TRUE .)
    RBRACKET        reduce using rule 63 (literal -> TRUE .)


state 102

    (64) literal -> FALSE .

    DOT             reduce using rule 64 (literal -> FALSE .)
    LBRACKET        reduce using rule 64 (literal -> FALSE .)
    RPAREN          reduce using rule 64 (literal -> FALSE .)
    PLUS            reduce using rule 64 (literal -> FALSE .)
    REMAIN          reduce using rule 64 (literal -> FALSE .)
    MINUS           reduce using rule 64 (literal -> FALSE .)
    MULTIPLY        reduce using rule 64 (literal -> FALSE .)
    DIVIDE          reduce using rule 64 (literal -> FALSE .)
    EQ              reduce using rule 64 (literal -> FALSE .)
    NEQ             reduce using rule 64 (literal -> FALSE .)
    LT              reduce using rule 64 (literal -> FALSE .)
    LEQ             reduce using rule 64 (literal -> FALSE .)
    GT              reduce using rule 64 (literal -> FALSE .)
    GEQ             reduce using rule 64 (literal -> FALSE .)
    AND             reduce using rule 64 (literal -> FALSE .)
    OR              reduce using rule 64 (literal -> FALSE .)
    SEMICOLON       reduce using rule 64 (literal -> FALSE .)
    COMMA           reduce using rule 64 (literal -> FALSE .)
    RBRACKET        reduce using rule 64 (literal -> FALSE .)


state 103

    (41) block -> LBRACE block_begin stmt_list block_end RBRACE .

    RBRACE          reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    PUBLIC          reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    PRIVATE         reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    VOID            reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    ID              reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    INT             reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    BOOLEAN         reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    FLOAT           reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    STATIC          reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    error           reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    IF              reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    WHILE           reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    FOR             reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    RETURN          reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    BREAK           reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    CONTINUE        reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    SEMICOLON       reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    LBRACE          reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    INC             reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    DEC             reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    THIS            reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    SUPER           reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    LPAREN          reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    NEW             reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    INT_CONST       reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    FLOAT_CONST     reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    STRING_CONST    reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    NULL            reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    TRUE            reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    FALSE           reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)
    ELSE            reduce using rule 41 (block -> LBRACE block_begin stmt_list block_end RBRACE .)


state 104

    (42) block -> LBRACE block_begin stmt_list error block_end . RBRACE

    RBRACE          shift and go to state 134


state 105

    (58) stmt -> error SEMICOLON .

    error           reduce using rule 58 (stmt -> error SEMICOLON .)
    IF              reduce using rule 58 (stmt -> error SEMICOLON .)
    WHILE           reduce using rule 58 (stmt -> error SEMICOLON .)
    FOR             reduce using rule 58 (stmt -> error SEMICOLON .)
    RETURN          reduce using rule 58 (stmt -> error SEMICOLON .)
    BREAK           reduce using rule 58 (stmt -> error SEMICOLON .)
    CONTINUE        reduce using rule 58 (stmt -> error SEMICOLON .)
    SEMICOLON       reduce using rule 58 (stmt -> error SEMICOLON .)
    LBRACE          reduce using rule 58 (stmt -> error SEMICOLON .)
    INC             reduce using rule 58 (stmt -> error SEMICOLON .)
    DEC             reduce using rule 58 (stmt -> error SEMICOLON .)
    INT             reduce using rule 58 (stmt -> error SEMICOLON .)
    BOOLEAN         reduce using rule 58 (stmt -> error SEMICOLON .)
    FLOAT           reduce using rule 58 (stmt -> error SEMICOLON .)
    ID              reduce using rule 58 (stmt -> error SEMICOLON .)
    THIS            reduce using rule 58 (stmt -> error SEMICOLON .)
    SUPER           reduce using rule 58 (stmt -> error SEMICOLON .)
    LPAREN          reduce using rule 58 (stmt -> error SEMICOLON .)
    NEW             reduce using rule 58 (stmt -> error SEMICOLON .)
    INT_CONST       reduce using rule 58 (stmt -> error SEMICOLON .)
    FLOAT_CONST     reduce using rule 58 (stmt -> error SEMICOLON .)
    STRING_CONST    reduce using rule 58 (stmt -> error SEMICOLON .)
    NULL            reduce using rule 58 (stmt -> error SEMICOLON .)
    TRUE            reduce using rule 58 (stmt -> error SEMICOLON .)
    FALSE           reduce using rule 58 (stmt -> error SEMICOLON .)
    RBRACE          reduce using rule 58 (stmt -> error SEMICOLON .)
    ELSE            reduce using rule 58 (stmt -> error SEMICOLON .)


state 106

    (47) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (48) stmt -> IF LPAREN . expr RPAREN stmt
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 135
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 107

    (68) primary -> LPAREN expr . RPAREN
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          shift and go to state 136
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 108

    (82) expr -> primary .
    (78) field_access -> primary . DOT ID
    (80) array_access -> primary . LBRACKET expr RBRACKET

    RPAREN          reduce using rule 82 (expr -> primary .)
    PLUS            reduce using rule 82 (expr -> primary .)
    REMAIN          reduce using rule 82 (expr -> primary .)
    MINUS           reduce using rule 82 (expr -> primary .)
    MULTIPLY        reduce using rule 82 (expr -> primary .)
    DIVIDE          reduce using rule 82 (expr -> primary .)
    EQ              reduce using rule 82 (expr -> primary .)
    NEQ             reduce using rule 82 (expr -> primary .)
    LT              reduce using rule 82 (expr -> primary .)
    LEQ             reduce using rule 82 (expr -> primary .)
    GT              reduce using rule 82 (expr -> primary .)
    GEQ             reduce using rule 82 (expr -> primary .)
    AND             reduce using rule 82 (expr -> primary .)
    OR              reduce using rule 82 (expr -> primary .)
    SEMICOLON       reduce using rule 82 (expr -> primary .)
    COMMA           reduce using rule 82 (expr -> primary .)
    RBRACKET        reduce using rule 82 (expr -> primary .)
    DOT             shift and go to state 131
    LBRACKET        shift and go to state 132


state 109

    (83) expr -> assign .

    RPAREN          reduce using rule 83 (expr -> assign .)
    PLUS            reduce using rule 83 (expr -> assign .)
    REMAIN          reduce using rule 83 (expr -> assign .)
    MINUS           reduce using rule 83 (expr -> assign .)
    MULTIPLY        reduce using rule 83 (expr -> assign .)
    DIVIDE          reduce using rule 83 (expr -> assign .)
    EQ              reduce using rule 83 (expr -> assign .)
    NEQ             reduce using rule 83 (expr -> assign .)
    LT              reduce using rule 83 (expr -> assign .)
    LEQ             reduce using rule 83 (expr -> assign .)
    GT              reduce using rule 83 (expr -> assign .)
    GEQ             reduce using rule 83 (expr -> assign .)
    AND             reduce using rule 83 (expr -> assign .)
    OR              reduce using rule 83 (expr -> assign .)
    SEMICOLON       reduce using rule 83 (expr -> assign .)
    COMMA           reduce using rule 83 (expr -> assign .)
    RBRACKET        reduce using rule 83 (expr -> assign .)


state 110

    (84) expr -> new_array .

    RPAREN          reduce using rule 84 (expr -> new_array .)
    PLUS            reduce using rule 84 (expr -> new_array .)
    REMAIN          reduce using rule 84 (expr -> new_array .)
    MINUS           reduce using rule 84 (expr -> new_array .)
    MULTIPLY        reduce using rule 84 (expr -> new_array .)
    DIVIDE          reduce using rule 84 (expr -> new_array .)
    EQ              reduce using rule 84 (expr -> new_array .)
    NEQ             reduce using rule 84 (expr -> new_array .)
    LT              reduce using rule 84 (expr -> new_array .)
    LEQ             reduce using rule 84 (expr -> new_array .)
    GT              reduce using rule 84 (expr -> new_array .)
    GEQ             reduce using rule 84 (expr -> new_array .)
    AND             reduce using rule 84 (expr -> new_array .)
    OR              reduce using rule 84 (expr -> new_array .)
    SEMICOLON       reduce using rule 84 (expr -> new_array .)
    COMMA           reduce using rule 84 (expr -> new_array .)
    RBRACKET        reduce using rule 84 (expr -> new_array .)


state 111

    (98) expr -> PLUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 150
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 112

    (99) expr -> MINUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 151
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 113

    (100) expr -> NOT . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 152
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 114

    (69) primary -> NEW . ID LPAREN args_opt RPAREN
    (106) new_array -> NEW . type dim_expr_plus dim_star
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID

    ID              shift and go to state 153
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32

    type                           shift and go to state 154

state 115

    (79) field_access -> ID .

    LPAREN          reduce using rule 79 (field_access -> ID .)
    ASSIGN          reduce using rule 79 (field_access -> ID .)
    INC             reduce using rule 79 (field_access -> ID .)
    DEC             reduce using rule 79 (field_access -> ID .)
    DOT             reduce using rule 79 (field_access -> ID .)
    LBRACKET        reduce using rule 79 (field_access -> ID .)
    RPAREN          reduce using rule 79 (field_access -> ID .)
    PLUS            reduce using rule 79 (field_access -> ID .)
    REMAIN          reduce using rule 79 (field_access -> ID .)
    MINUS           reduce using rule 79 (field_access -> ID .)
    MULTIPLY        reduce using rule 79 (field_access -> ID .)
    DIVIDE          reduce using rule 79 (field_access -> ID .)
    EQ              reduce using rule 79 (field_access -> ID .)
    NEQ             reduce using rule 79 (field_access -> ID .)
    LT              reduce using rule 79 (field_access -> ID .)
    LEQ             reduce using rule 79 (field_access -> ID .)
    GT              reduce using rule 79 (field_access -> ID .)
    GEQ             reduce using rule 79 (field_access -> ID .)
    AND             reduce using rule 79 (field_access -> ID .)
    OR              reduce using rule 79 (field_access -> ID .)
    SEMICOLON       reduce using rule 79 (field_access -> ID .)
    COMMA           reduce using rule 79 (field_access -> ID .)
    RBRACKET        reduce using rule 79 (field_access -> ID .)


state 116

    (70) primary -> lhs .
    (101) assign -> lhs . ASSIGN expr
    (102) assign -> lhs . INC
    (104) assign -> lhs . DEC

    DOT             reduce using rule 70 (primary -> lhs .)
    LBRACKET        reduce using rule 70 (primary -> lhs .)
    RPAREN          reduce using rule 70 (primary -> lhs .)
    PLUS            reduce using rule 70 (primary -> lhs .)
    REMAIN          reduce using rule 70 (primary -> lhs .)
    MINUS           reduce using rule 70 (primary -> lhs .)
    MULTIPLY        reduce using rule 70 (primary -> lhs .)
    DIVIDE          reduce using rule 70 (primary -> lhs .)
    EQ              reduce using rule 70 (primary -> lhs .)
    NEQ             reduce using rule 70 (primary -> lhs .)
    LT              reduce using rule 70 (primary -> lhs .)
    LEQ             reduce using rule 70 (primary -> lhs .)
    GT              reduce using rule 70 (primary -> lhs .)
    GEQ             reduce using rule 70 (primary -> lhs .)
    AND             reduce using rule 70 (primary -> lhs .)
    OR              reduce using rule 70 (primary -> lhs .)
    SEMICOLON       reduce using rule 70 (primary -> lhs .)
    COMMA           reduce using rule 70 (primary -> lhs .)
    RBRACKET        reduce using rule 70 (primary -> lhs .)
    ASSIGN          shift and go to state 125
    INC             shift and go to state 126
    DEC             shift and go to state 127


state 117

    (71) primary -> method_invocation .

    DOT             reduce using rule 71 (primary -> method_invocation .)
    LBRACKET        reduce using rule 71 (primary -> method_invocation .)
    RPAREN          reduce using rule 71 (primary -> method_invocation .)
    PLUS            reduce using rule 71 (primary -> method_invocation .)
    REMAIN          reduce using rule 71 (primary -> method_invocation .)
    MINUS           reduce using rule 71 (primary -> method_invocation .)
    MULTIPLY        reduce using rule 71 (primary -> method_invocation .)
    DIVIDE          reduce using rule 71 (primary -> method_invocation .)
    EQ              reduce using rule 71 (primary -> method_invocation .)
    NEQ             reduce using rule 71 (primary -> method_invocation .)
    LT              reduce using rule 71 (primary -> method_invocation .)
    LEQ             reduce using rule 71 (primary -> method_invocation .)
    GT              reduce using rule 71 (primary -> method_invocation .)
    GEQ             reduce using rule 71 (primary -> method_invocation .)
    AND             reduce using rule 71 (primary -> method_invocation .)
    OR              reduce using rule 71 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 71 (primary -> method_invocation .)
    COMMA           reduce using rule 71 (primary -> method_invocation .)
    RBRACKET        reduce using rule 71 (primary -> method_invocation .)


state 118

    (76) lhs -> field_access .
    (81) method_invocation -> field_access . LPAREN args_opt RPAREN

    ASSIGN          reduce using rule 76 (lhs -> field_access .)
    INC             reduce using rule 76 (lhs -> field_access .)
    DEC             reduce using rule 76 (lhs -> field_access .)
    DOT             reduce using rule 76 (lhs -> field_access .)
    LBRACKET        reduce using rule 76 (lhs -> field_access .)
    RPAREN          reduce using rule 76 (lhs -> field_access .)
    PLUS            reduce using rule 76 (lhs -> field_access .)
    REMAIN          reduce using rule 76 (lhs -> field_access .)
    MINUS           reduce using rule 76 (lhs -> field_access .)
    MULTIPLY        reduce using rule 76 (lhs -> field_access .)
    DIVIDE          reduce using rule 76 (lhs -> field_access .)
    EQ              reduce using rule 76 (lhs -> field_access .)
    NEQ             reduce using rule 76 (lhs -> field_access .)
    LT              reduce using rule 76 (lhs -> field_access .)
    LEQ             reduce using rule 76 (lhs -> field_access .)
    GT              reduce using rule 76 (lhs -> field_access .)
    GEQ             reduce using rule 76 (lhs -> field_access .)
    AND             reduce using rule 76 (lhs -> field_access .)
    OR              reduce using rule 76 (lhs -> field_access .)
    SEMICOLON       reduce using rule 76 (lhs -> field_access .)
    COMMA           reduce using rule 76 (lhs -> field_access .)
    RBRACKET        reduce using rule 76 (lhs -> field_access .)
    LPAREN          shift and go to state 130


state 119

    (49) stmt -> WHILE LPAREN . expr RPAREN stmt
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 155
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 120

    (50) stmt -> FOR LPAREN . stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (114) stmt_expr_opt -> . stmt_expr
    (115) stmt_expr_opt -> .
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    SEMICOLON       reduce using rule 115 (stmt_expr_opt -> .)
    INC             shift and go to state 87
    DEC             shift and go to state 88
    ID              shift and go to state 115
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt_expr_opt                  shift and go to state 156
    stmt_expr                      shift and go to state 157
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 121

    (51) stmt -> RETURN LPAREN . expr_opt RPAREN SEMICOLON
    (116) expr_opt -> . expr
    (117) expr_opt -> .
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    RPAREN          reduce using rule 117 (expr_opt -> .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr_opt                       shift and go to state 158
    expr                           shift and go to state 159
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 122

    (52) stmt -> stmt_expr SEMICOLON .

    error           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    IF              reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    LBRACE          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    INC             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    DEC             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    RBRACE          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)


state 123

    (53) stmt -> BREAK SEMICOLON .

    error           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    INC             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    DEC             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 53 (stmt -> BREAK SEMICOLON .)


state 124

    (54) stmt -> CONTINUE SEMICOLON .

    error           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    INC             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    DEC             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)


state 125

    (101) assign -> lhs ASSIGN . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    lhs                            shift and go to state 116
    expr                           shift and go to state 160
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 126

    (102) assign -> lhs INC .

    SEMICOLON       reduce using rule 102 (assign -> lhs INC .)
    RPAREN          reduce using rule 102 (assign -> lhs INC .)
    PLUS            reduce using rule 102 (assign -> lhs INC .)
    REMAIN          reduce using rule 102 (assign -> lhs INC .)
    MINUS           reduce using rule 102 (assign -> lhs INC .)
    MULTIPLY        reduce using rule 102 (assign -> lhs INC .)
    DIVIDE          reduce using rule 102 (assign -> lhs INC .)
    EQ              reduce using rule 102 (assign -> lhs INC .)
    NEQ             reduce using rule 102 (assign -> lhs INC .)
    LT              reduce using rule 102 (assign -> lhs INC .)
    LEQ             reduce using rule 102 (assign -> lhs INC .)
    GT              reduce using rule 102 (assign -> lhs INC .)
    GEQ             reduce using rule 102 (assign -> lhs INC .)
    AND             reduce using rule 102 (assign -> lhs INC .)
    OR              reduce using rule 102 (assign -> lhs INC .)
    COMMA           reduce using rule 102 (assign -> lhs INC .)
    RBRACKET        reduce using rule 102 (assign -> lhs INC .)


state 127

    (104) assign -> lhs DEC .

    SEMICOLON       reduce using rule 104 (assign -> lhs DEC .)
    RPAREN          reduce using rule 104 (assign -> lhs DEC .)
    PLUS            reduce using rule 104 (assign -> lhs DEC .)
    REMAIN          reduce using rule 104 (assign -> lhs DEC .)
    MINUS           reduce using rule 104 (assign -> lhs DEC .)
    MULTIPLY        reduce using rule 104 (assign -> lhs DEC .)
    DIVIDE          reduce using rule 104 (assign -> lhs DEC .)
    EQ              reduce using rule 104 (assign -> lhs DEC .)
    NEQ             reduce using rule 104 (assign -> lhs DEC .)
    LT              reduce using rule 104 (assign -> lhs DEC .)
    LEQ             reduce using rule 104 (assign -> lhs DEC .)
    GT              reduce using rule 104 (assign -> lhs DEC .)
    GEQ             reduce using rule 104 (assign -> lhs DEC .)
    AND             reduce using rule 104 (assign -> lhs DEC .)
    OR              reduce using rule 104 (assign -> lhs DEC .)
    COMMA           reduce using rule 104 (assign -> lhs DEC .)
    RBRACKET        reduce using rule 104 (assign -> lhs DEC .)


state 128

    (103) assign -> INC lhs .
    (70) primary -> lhs .

    SEMICOLON       reduce using rule 103 (assign -> INC lhs .)
    RPAREN          reduce using rule 103 (assign -> INC lhs .)
    PLUS            reduce using rule 103 (assign -> INC lhs .)
    REMAIN          reduce using rule 103 (assign -> INC lhs .)
    MINUS           reduce using rule 103 (assign -> INC lhs .)
    MULTIPLY        reduce using rule 103 (assign -> INC lhs .)
    DIVIDE          reduce using rule 103 (assign -> INC lhs .)
    EQ              reduce using rule 103 (assign -> INC lhs .)
    NEQ             reduce using rule 103 (assign -> INC lhs .)
    LT              reduce using rule 103 (assign -> INC lhs .)
    LEQ             reduce using rule 103 (assign -> INC lhs .)
    GT              reduce using rule 103 (assign -> INC lhs .)
    GEQ             reduce using rule 103 (assign -> INC lhs .)
    AND             reduce using rule 103 (assign -> INC lhs .)
    OR              reduce using rule 103 (assign -> INC lhs .)
    COMMA           reduce using rule 103 (assign -> INC lhs .)
    RBRACKET        reduce using rule 103 (assign -> INC lhs .)
    DOT             reduce using rule 70 (primary -> lhs .)
    LBRACKET        reduce using rule 70 (primary -> lhs .)


state 129

    (105) assign -> DEC lhs .
    (70) primary -> lhs .

    SEMICOLON       reduce using rule 105 (assign -> DEC lhs .)
    RPAREN          reduce using rule 105 (assign -> DEC lhs .)
    PLUS            reduce using rule 105 (assign -> DEC lhs .)
    REMAIN          reduce using rule 105 (assign -> DEC lhs .)
    MINUS           reduce using rule 105 (assign -> DEC lhs .)
    MULTIPLY        reduce using rule 105 (assign -> DEC lhs .)
    DIVIDE          reduce using rule 105 (assign -> DEC lhs .)
    EQ              reduce using rule 105 (assign -> DEC lhs .)
    NEQ             reduce using rule 105 (assign -> DEC lhs .)
    LT              reduce using rule 105 (assign -> DEC lhs .)
    LEQ             reduce using rule 105 (assign -> DEC lhs .)
    GT              reduce using rule 105 (assign -> DEC lhs .)
    GEQ             reduce using rule 105 (assign -> DEC lhs .)
    AND             reduce using rule 105 (assign -> DEC lhs .)
    OR              reduce using rule 105 (assign -> DEC lhs .)
    COMMA           reduce using rule 105 (assign -> DEC lhs .)
    RBRACKET        reduce using rule 105 (assign -> DEC lhs .)
    DOT             reduce using rule 70 (primary -> lhs .)
    LBRACKET        reduce using rule 70 (primary -> lhs .)


state 130

    (81) method_invocation -> field_access LPAREN . args_opt RPAREN
    (72) args_opt -> . arg_plus
    (73) args_opt -> .
    (74) arg_plus -> . arg_plus COMMA expr
    (75) arg_plus -> . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    RPAREN          reduce using rule 73 (args_opt -> .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    field_access                   shift and go to state 118
    args_opt                       shift and go to state 161
    arg_plus                       shift and go to state 162
    expr                           shift and go to state 163
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    array_access                   shift and go to state 91

state 131

    (78) field_access -> primary DOT . ID

    ID              shift and go to state 164


state 132

    (80) array_access -> primary LBRACKET . expr RBRACKET
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    primary                        shift and go to state 108
    expr                           shift and go to state 165
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 133

    (69) primary -> NEW ID . LPAREN args_opt RPAREN

    LPAREN          shift and go to state 166


state 134

    (42) block -> LBRACE block_begin stmt_list error block_end RBRACE .

    RBRACE          reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    PUBLIC          reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    PRIVATE         reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    VOID            reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    ID              reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    INT             reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    BOOLEAN         reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    FLOAT           reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    STATIC          reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    error           reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    IF              reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    WHILE           reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    FOR             reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    RETURN          reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    BREAK           reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    CONTINUE        reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    SEMICOLON       reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    LBRACE          reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    INC             reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    DEC             reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    THIS            reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    SUPER           reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    LPAREN          reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    NEW             reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    INT_CONST       reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    FLOAT_CONST     reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    STRING_CONST    reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    NULL            reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    TRUE            reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    FALSE           reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)
    ELSE            reduce using rule 42 (block -> LBRACE block_begin stmt_list error block_end RBRACE .)


state 135

    (47) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (48) stmt -> IF LPAREN expr . RPAREN stmt
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          shift and go to state 167
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 136

    (68) primary -> LPAREN expr RPAREN .

    DOT             reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    REMAIN          reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    MULTIPLY        reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    EQ              reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    NEQ             reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    LT              reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    LEQ             reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    GT              reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    GEQ             reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 68 (primary -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 68 (primary -> LPAREN expr RPAREN .)


state 137

    (85) expr -> expr PLUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 168
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 138

    (86) expr -> expr REMAIN . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 169
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 139

    (87) expr -> expr MINUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 170
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 140

    (88) expr -> expr MULTIPLY . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 171
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 141

    (89) expr -> expr DIVIDE . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 172
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 142

    (90) expr -> expr EQ . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 173
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 143

    (91) expr -> expr NEQ . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 174
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 144

    (92) expr -> expr LT . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 175
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 145

    (93) expr -> expr LEQ . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 176
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 146

    (94) expr -> expr GT . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 177
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 147

    (95) expr -> expr GEQ . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 178
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 148

    (96) expr -> expr AND . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 179
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 149

    (97) expr -> expr OR . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 180
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 150

    (98) expr -> PLUS expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 98 (expr -> PLUS expr .)
    PLUS            reduce using rule 98 (expr -> PLUS expr .)
    REMAIN          reduce using rule 98 (expr -> PLUS expr .)
    MINUS           reduce using rule 98 (expr -> PLUS expr .)
    MULTIPLY        reduce using rule 98 (expr -> PLUS expr .)
    DIVIDE          reduce using rule 98 (expr -> PLUS expr .)
    EQ              reduce using rule 98 (expr -> PLUS expr .)
    NEQ             reduce using rule 98 (expr -> PLUS expr .)
    LT              reduce using rule 98 (expr -> PLUS expr .)
    LEQ             reduce using rule 98 (expr -> PLUS expr .)
    GT              reduce using rule 98 (expr -> PLUS expr .)
    GEQ             reduce using rule 98 (expr -> PLUS expr .)
    AND             reduce using rule 98 (expr -> PLUS expr .)
    OR              reduce using rule 98 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 98 (expr -> PLUS expr .)
    COMMA           reduce using rule 98 (expr -> PLUS expr .)
    RBRACKET        reduce using rule 98 (expr -> PLUS expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! REMAIN          [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULTIPLY        [ shift and go to state 140 ]
  ! DIVIDE          [ shift and go to state 141 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 151

    (99) expr -> MINUS expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 99 (expr -> MINUS expr .)
    PLUS            reduce using rule 99 (expr -> MINUS expr .)
    REMAIN          reduce using rule 99 (expr -> MINUS expr .)
    MINUS           reduce using rule 99 (expr -> MINUS expr .)
    MULTIPLY        reduce using rule 99 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 99 (expr -> MINUS expr .)
    EQ              reduce using rule 99 (expr -> MINUS expr .)
    NEQ             reduce using rule 99 (expr -> MINUS expr .)
    LT              reduce using rule 99 (expr -> MINUS expr .)
    LEQ             reduce using rule 99 (expr -> MINUS expr .)
    GT              reduce using rule 99 (expr -> MINUS expr .)
    GEQ             reduce using rule 99 (expr -> MINUS expr .)
    AND             reduce using rule 99 (expr -> MINUS expr .)
    OR              reduce using rule 99 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 99 (expr -> MINUS expr .)
    COMMA           reduce using rule 99 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 99 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! REMAIN          [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULTIPLY        [ shift and go to state 140 ]
  ! DIVIDE          [ shift and go to state 141 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 152

    (100) expr -> NOT expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 100 (expr -> NOT expr .)
    PLUS            reduce using rule 100 (expr -> NOT expr .)
    REMAIN          reduce using rule 100 (expr -> NOT expr .)
    MINUS           reduce using rule 100 (expr -> NOT expr .)
    MULTIPLY        reduce using rule 100 (expr -> NOT expr .)
    DIVIDE          reduce using rule 100 (expr -> NOT expr .)
    EQ              reduce using rule 100 (expr -> NOT expr .)
    NEQ             reduce using rule 100 (expr -> NOT expr .)
    LT              reduce using rule 100 (expr -> NOT expr .)
    LEQ             reduce using rule 100 (expr -> NOT expr .)
    GT              reduce using rule 100 (expr -> NOT expr .)
    GEQ             reduce using rule 100 (expr -> NOT expr .)
    AND             reduce using rule 100 (expr -> NOT expr .)
    OR              reduce using rule 100 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 100 (expr -> NOT expr .)
    COMMA           reduce using rule 100 (expr -> NOT expr .)
    RBRACKET        reduce using rule 100 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! REMAIN          [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULTIPLY        [ shift and go to state 140 ]
  ! DIVIDE          [ shift and go to state 141 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 153

    (69) primary -> NEW ID . LPAREN args_opt RPAREN
    (30) type -> ID .

    LPAREN          shift and go to state 166
    LBRACKET        reduce using rule 30 (type -> ID .)


state 154

    (106) new_array -> NEW type . dim_expr_plus dim_star
    (107) dim_expr_plus -> . dim_expr_plus dim_expr
    (108) dim_expr_plus -> . dim_expr
    (109) dim_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 183

    dim_expr_plus                  shift and go to state 181
    dim_expr                       shift and go to state 182

state 155

    (49) stmt -> WHILE LPAREN expr . RPAREN stmt
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          shift and go to state 184
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 156

    (50) stmt -> FOR LPAREN stmt_expr_opt . SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt

    SEMICOLON       shift and go to state 185


state 157

    (114) stmt_expr_opt -> stmt_expr .

    SEMICOLON       reduce using rule 114 (stmt_expr_opt -> stmt_expr .)
    RPAREN          reduce using rule 114 (stmt_expr_opt -> stmt_expr .)


state 158

    (51) stmt -> RETURN LPAREN expr_opt . RPAREN SEMICOLON

    RPAREN          shift and go to state 186


state 159

    (116) expr_opt -> expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 116 (expr_opt -> expr .)
    SEMICOLON       reduce using rule 116 (expr_opt -> expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 160

    (101) assign -> lhs ASSIGN expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    SEMICOLON       reduce using rule 101 (assign -> lhs ASSIGN expr .)
    RPAREN          reduce using rule 101 (assign -> lhs ASSIGN expr .)
    COMMA           reduce using rule 101 (assign -> lhs ASSIGN expr .)
    RBRACKET        reduce using rule 101 (assign -> lhs ASSIGN expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149

  ! PLUS            [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! REMAIN          [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! MULTIPLY        [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! EQ              [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! NEQ             [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! LT              [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! LEQ             [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! GT              [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! GEQ             [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! AND             [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]
  ! OR              [ reduce using rule 101 (assign -> lhs ASSIGN expr .) ]


state 161

    (81) method_invocation -> field_access LPAREN args_opt . RPAREN

    RPAREN          shift and go to state 187


state 162

    (72) args_opt -> arg_plus .
    (74) arg_plus -> arg_plus . COMMA expr

    RPAREN          reduce using rule 72 (args_opt -> arg_plus .)
    COMMA           shift and go to state 188


state 163

    (75) arg_plus -> expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    COMMA           reduce using rule 75 (arg_plus -> expr .)
    RPAREN          reduce using rule 75 (arg_plus -> expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 164

    (78) field_access -> primary DOT ID .

    LPAREN          reduce using rule 78 (field_access -> primary DOT ID .)
    ASSIGN          reduce using rule 78 (field_access -> primary DOT ID .)
    INC             reduce using rule 78 (field_access -> primary DOT ID .)
    DEC             reduce using rule 78 (field_access -> primary DOT ID .)
    DOT             reduce using rule 78 (field_access -> primary DOT ID .)
    LBRACKET        reduce using rule 78 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 78 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 78 (field_access -> primary DOT ID .)
    REMAIN          reduce using rule 78 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 78 (field_access -> primary DOT ID .)
    MULTIPLY        reduce using rule 78 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 78 (field_access -> primary DOT ID .)
    EQ              reduce using rule 78 (field_access -> primary DOT ID .)
    NEQ             reduce using rule 78 (field_access -> primary DOT ID .)
    LT              reduce using rule 78 (field_access -> primary DOT ID .)
    LEQ             reduce using rule 78 (field_access -> primary DOT ID .)
    GT              reduce using rule 78 (field_access -> primary DOT ID .)
    GEQ             reduce using rule 78 (field_access -> primary DOT ID .)
    AND             reduce using rule 78 (field_access -> primary DOT ID .)
    OR              reduce using rule 78 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 78 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 78 (field_access -> primary DOT ID .)
    RBRACKET        reduce using rule 78 (field_access -> primary DOT ID .)


state 165

    (80) array_access -> primary LBRACKET expr . RBRACKET
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RBRACKET        shift and go to state 189
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 166

    (69) primary -> NEW ID LPAREN . args_opt RPAREN
    (72) args_opt -> . arg_plus
    (73) args_opt -> .
    (74) arg_plus -> . arg_plus COMMA expr
    (75) arg_plus -> . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    RPAREN          reduce using rule 73 (args_opt -> .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    args_opt                       shift and go to state 190
    arg_plus                       shift and go to state 162
    expr                           shift and go to state 163
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 167

    (47) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (48) stmt -> IF LPAREN expr RPAREN . stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . IF LPAREN expr RPAREN stmt
    (49) stmt -> . WHILE LPAREN expr RPAREN stmt
    (50) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (51) stmt -> . RETURN LPAREN expr_opt RPAREN SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (58) stmt -> . error SEMICOLON
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE
    (26) var_decl -> . type var_list SEMICOLON
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    IF              shift and go to state 72
    WHILE           shift and go to state 74
    FOR             shift and go to state 75
    RETURN          shift and go to state 77
    BREAK           shift and go to state 79
    CONTINUE        shift and go to state 80
    SEMICOLON       shift and go to state 76
    error           shift and go to state 192
    LBRACE          shift and go to state 60
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 90
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt                           shift and go to state 191
    stmt_expr                      shift and go to state 78
    block                          shift and go to state 81
    var_decl                       shift and go to state 82
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    type                           shift and go to state 85
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 168

    (85) expr -> expr PLUS expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 85 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 85 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 85 (expr -> expr PLUS expr .)
    EQ              reduce using rule 85 (expr -> expr PLUS expr .)
    NEQ             reduce using rule 85 (expr -> expr PLUS expr .)
    LT              reduce using rule 85 (expr -> expr PLUS expr .)
    LEQ             reduce using rule 85 (expr -> expr PLUS expr .)
    GT              reduce using rule 85 (expr -> expr PLUS expr .)
    GEQ             reduce using rule 85 (expr -> expr PLUS expr .)
    AND             reduce using rule 85 (expr -> expr PLUS expr .)
    OR              reduce using rule 85 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 85 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 85 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 85 (expr -> expr PLUS expr .)
    REMAIN          shift and go to state 138
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141

  ! REMAIN          [ reduce using rule 85 (expr -> expr PLUS expr .) ]
  ! MULTIPLY        [ reduce using rule 85 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 85 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 169

    (86) expr -> expr REMAIN expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 86 (expr -> expr REMAIN expr .)
    PLUS            reduce using rule 86 (expr -> expr REMAIN expr .)
    REMAIN          reduce using rule 86 (expr -> expr REMAIN expr .)
    MINUS           reduce using rule 86 (expr -> expr REMAIN expr .)
    MULTIPLY        reduce using rule 86 (expr -> expr REMAIN expr .)
    DIVIDE          reduce using rule 86 (expr -> expr REMAIN expr .)
    EQ              reduce using rule 86 (expr -> expr REMAIN expr .)
    NEQ             reduce using rule 86 (expr -> expr REMAIN expr .)
    LT              reduce using rule 86 (expr -> expr REMAIN expr .)
    LEQ             reduce using rule 86 (expr -> expr REMAIN expr .)
    GT              reduce using rule 86 (expr -> expr REMAIN expr .)
    GEQ             reduce using rule 86 (expr -> expr REMAIN expr .)
    AND             reduce using rule 86 (expr -> expr REMAIN expr .)
    OR              reduce using rule 86 (expr -> expr REMAIN expr .)
    SEMICOLON       reduce using rule 86 (expr -> expr REMAIN expr .)
    COMMA           reduce using rule 86 (expr -> expr REMAIN expr .)
    RBRACKET        reduce using rule 86 (expr -> expr REMAIN expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! REMAIN          [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULTIPLY        [ shift and go to state 140 ]
  ! DIVIDE          [ shift and go to state 141 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 170

    (87) expr -> expr MINUS expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 87 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 87 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 87 (expr -> expr MINUS expr .)
    EQ              reduce using rule 87 (expr -> expr MINUS expr .)
    NEQ             reduce using rule 87 (expr -> expr MINUS expr .)
    LT              reduce using rule 87 (expr -> expr MINUS expr .)
    LEQ             reduce using rule 87 (expr -> expr MINUS expr .)
    GT              reduce using rule 87 (expr -> expr MINUS expr .)
    GEQ             reduce using rule 87 (expr -> expr MINUS expr .)
    AND             reduce using rule 87 (expr -> expr MINUS expr .)
    OR              reduce using rule 87 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 87 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 87 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 87 (expr -> expr MINUS expr .)
    REMAIN          shift and go to state 138
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141

  ! REMAIN          [ reduce using rule 87 (expr -> expr MINUS expr .) ]
  ! MULTIPLY        [ reduce using rule 87 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 87 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 137 ]
  ! MINUS           [ shift and go to state 139 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 171

    (88) expr -> expr MULTIPLY expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 88 (expr -> expr MULTIPLY expr .)
    PLUS            reduce using rule 88 (expr -> expr MULTIPLY expr .)
    REMAIN          reduce using rule 88 (expr -> expr MULTIPLY expr .)
    MINUS           reduce using rule 88 (expr -> expr MULTIPLY expr .)
    MULTIPLY        reduce using rule 88 (expr -> expr MULTIPLY expr .)
    DIVIDE          reduce using rule 88 (expr -> expr MULTIPLY expr .)
    EQ              reduce using rule 88 (expr -> expr MULTIPLY expr .)
    NEQ             reduce using rule 88 (expr -> expr MULTIPLY expr .)
    LT              reduce using rule 88 (expr -> expr MULTIPLY expr .)
    LEQ             reduce using rule 88 (expr -> expr MULTIPLY expr .)
    GT              reduce using rule 88 (expr -> expr MULTIPLY expr .)
    GEQ             reduce using rule 88 (expr -> expr MULTIPLY expr .)
    AND             reduce using rule 88 (expr -> expr MULTIPLY expr .)
    OR              reduce using rule 88 (expr -> expr MULTIPLY expr .)
    SEMICOLON       reduce using rule 88 (expr -> expr MULTIPLY expr .)
    COMMA           reduce using rule 88 (expr -> expr MULTIPLY expr .)
    RBRACKET        reduce using rule 88 (expr -> expr MULTIPLY expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! REMAIN          [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULTIPLY        [ shift and go to state 140 ]
  ! DIVIDE          [ shift and go to state 141 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 172

    (89) expr -> expr DIVIDE expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 89 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 89 (expr -> expr DIVIDE expr .)
    REMAIN          reduce using rule 89 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 89 (expr -> expr DIVIDE expr .)
    MULTIPLY        reduce using rule 89 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 89 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 89 (expr -> expr DIVIDE expr .)
    NEQ             reduce using rule 89 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 89 (expr -> expr DIVIDE expr .)
    LEQ             reduce using rule 89 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 89 (expr -> expr DIVIDE expr .)
    GEQ             reduce using rule 89 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 89 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 89 (expr -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 89 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 89 (expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 89 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 137 ]
  ! REMAIN          [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 139 ]
  ! MULTIPLY        [ shift and go to state 140 ]
  ! DIVIDE          [ shift and go to state 141 ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 173

    (90) expr -> expr EQ expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 90 (expr -> expr EQ expr .)
    EQ              reduce using rule 90 (expr -> expr EQ expr .)
    NEQ             reduce using rule 90 (expr -> expr EQ expr .)
    AND             reduce using rule 90 (expr -> expr EQ expr .)
    OR              reduce using rule 90 (expr -> expr EQ expr .)
    SEMICOLON       reduce using rule 90 (expr -> expr EQ expr .)
    COMMA           reduce using rule 90 (expr -> expr EQ expr .)
    RBRACKET        reduce using rule 90 (expr -> expr EQ expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147

  ! PLUS            [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! REMAIN          [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! MULTIPLY        [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! LEQ             [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! GEQ             [ reduce using rule 90 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 174

    (91) expr -> expr NEQ expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 91 (expr -> expr NEQ expr .)
    EQ              reduce using rule 91 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 91 (expr -> expr NEQ expr .)
    AND             reduce using rule 91 (expr -> expr NEQ expr .)
    OR              reduce using rule 91 (expr -> expr NEQ expr .)
    SEMICOLON       reduce using rule 91 (expr -> expr NEQ expr .)
    COMMA           reduce using rule 91 (expr -> expr NEQ expr .)
    RBRACKET        reduce using rule 91 (expr -> expr NEQ expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147

  ! PLUS            [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! REMAIN          [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! MINUS           [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! DIVIDE          [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! LT              [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! LEQ             [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! GT              [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! GEQ             [ reduce using rule 91 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 175

    (92) expr -> expr LT expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 92 (expr -> expr LT expr .)
    EQ              reduce using rule 92 (expr -> expr LT expr .)
    NEQ             reduce using rule 92 (expr -> expr LT expr .)
    LT              reduce using rule 92 (expr -> expr LT expr .)
    LEQ             reduce using rule 92 (expr -> expr LT expr .)
    GT              reduce using rule 92 (expr -> expr LT expr .)
    GEQ             reduce using rule 92 (expr -> expr LT expr .)
    AND             reduce using rule 92 (expr -> expr LT expr .)
    OR              reduce using rule 92 (expr -> expr LT expr .)
    SEMICOLON       reduce using rule 92 (expr -> expr LT expr .)
    COMMA           reduce using rule 92 (expr -> expr LT expr .)
    RBRACKET        reduce using rule 92 (expr -> expr LT expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141

  ! PLUS            [ reduce using rule 92 (expr -> expr LT expr .) ]
  ! REMAIN          [ reduce using rule 92 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 92 (expr -> expr LT expr .) ]
  ! MULTIPLY        [ reduce using rule 92 (expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 92 (expr -> expr LT expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 176

    (93) expr -> expr LEQ expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 93 (expr -> expr LEQ expr .)
    EQ              reduce using rule 93 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 93 (expr -> expr LEQ expr .)
    LT              reduce using rule 93 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 93 (expr -> expr LEQ expr .)
    GT              reduce using rule 93 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 93 (expr -> expr LEQ expr .)
    AND             reduce using rule 93 (expr -> expr LEQ expr .)
    OR              reduce using rule 93 (expr -> expr LEQ expr .)
    SEMICOLON       reduce using rule 93 (expr -> expr LEQ expr .)
    COMMA           reduce using rule 93 (expr -> expr LEQ expr .)
    RBRACKET        reduce using rule 93 (expr -> expr LEQ expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141

  ! PLUS            [ reduce using rule 93 (expr -> expr LEQ expr .) ]
  ! REMAIN          [ reduce using rule 93 (expr -> expr LEQ expr .) ]
  ! MINUS           [ reduce using rule 93 (expr -> expr LEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 93 (expr -> expr LEQ expr .) ]
  ! DIVIDE          [ reduce using rule 93 (expr -> expr LEQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 177

    (94) expr -> expr GT expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 94 (expr -> expr GT expr .)
    EQ              reduce using rule 94 (expr -> expr GT expr .)
    NEQ             reduce using rule 94 (expr -> expr GT expr .)
    LT              reduce using rule 94 (expr -> expr GT expr .)
    LEQ             reduce using rule 94 (expr -> expr GT expr .)
    GT              reduce using rule 94 (expr -> expr GT expr .)
    GEQ             reduce using rule 94 (expr -> expr GT expr .)
    AND             reduce using rule 94 (expr -> expr GT expr .)
    OR              reduce using rule 94 (expr -> expr GT expr .)
    SEMICOLON       reduce using rule 94 (expr -> expr GT expr .)
    COMMA           reduce using rule 94 (expr -> expr GT expr .)
    RBRACKET        reduce using rule 94 (expr -> expr GT expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141

  ! PLUS            [ reduce using rule 94 (expr -> expr GT expr .) ]
  ! REMAIN          [ reduce using rule 94 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 94 (expr -> expr GT expr .) ]
  ! MULTIPLY        [ reduce using rule 94 (expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 94 (expr -> expr GT expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 178

    (95) expr -> expr GEQ expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 95 (expr -> expr GEQ expr .)
    EQ              reduce using rule 95 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 95 (expr -> expr GEQ expr .)
    LT              reduce using rule 95 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 95 (expr -> expr GEQ expr .)
    GT              reduce using rule 95 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 95 (expr -> expr GEQ expr .)
    AND             reduce using rule 95 (expr -> expr GEQ expr .)
    OR              reduce using rule 95 (expr -> expr GEQ expr .)
    SEMICOLON       reduce using rule 95 (expr -> expr GEQ expr .)
    COMMA           reduce using rule 95 (expr -> expr GEQ expr .)
    RBRACKET        reduce using rule 95 (expr -> expr GEQ expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141

  ! PLUS            [ reduce using rule 95 (expr -> expr GEQ expr .) ]
  ! REMAIN          [ reduce using rule 95 (expr -> expr GEQ expr .) ]
  ! MINUS           [ reduce using rule 95 (expr -> expr GEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 95 (expr -> expr GEQ expr .) ]
  ! DIVIDE          [ reduce using rule 95 (expr -> expr GEQ expr .) ]
  ! EQ              [ shift and go to state 142 ]
  ! NEQ             [ shift and go to state 143 ]
  ! LT              [ shift and go to state 144 ]
  ! LEQ             [ shift and go to state 145 ]
  ! GT              [ shift and go to state 146 ]
  ! GEQ             [ shift and go to state 147 ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 179

    (96) expr -> expr AND expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 96 (expr -> expr AND expr .)
    AND             reduce using rule 96 (expr -> expr AND expr .)
    OR              reduce using rule 96 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 96 (expr -> expr AND expr .)
    COMMA           reduce using rule 96 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 96 (expr -> expr AND expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147

  ! PLUS            [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! REMAIN          [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! MULTIPLY        [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! NEQ             [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! LEQ             [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! GEQ             [ reduce using rule 96 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 148 ]
  ! OR              [ shift and go to state 149 ]


state 180

    (97) expr -> expr OR expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RPAREN          reduce using rule 97 (expr -> expr OR expr .)
    OR              reduce using rule 97 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 97 (expr -> expr OR expr .)
    COMMA           reduce using rule 97 (expr -> expr OR expr .)
    RBRACKET        reduce using rule 97 (expr -> expr OR expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148

  ! PLUS            [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! REMAIN          [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! MULTIPLY        [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! NEQ             [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! LEQ             [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! GEQ             [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 97 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 149 ]


state 181

    (106) new_array -> NEW type dim_expr_plus . dim_star
    (107) dim_expr_plus -> dim_expr_plus . dim_expr
    (110) dim_star -> . LBRACKET RBRACKET dim_star
    (111) dim_star -> .
    (109) dim_expr -> . LBRACKET expr RBRACKET

    LBRACKET        shift and go to state 195
    RPAREN          reduce using rule 111 (dim_star -> .)
    PLUS            reduce using rule 111 (dim_star -> .)
    REMAIN          reduce using rule 111 (dim_star -> .)
    MINUS           reduce using rule 111 (dim_star -> .)
    MULTIPLY        reduce using rule 111 (dim_star -> .)
    DIVIDE          reduce using rule 111 (dim_star -> .)
    EQ              reduce using rule 111 (dim_star -> .)
    NEQ             reduce using rule 111 (dim_star -> .)
    LT              reduce using rule 111 (dim_star -> .)
    LEQ             reduce using rule 111 (dim_star -> .)
    GT              reduce using rule 111 (dim_star -> .)
    GEQ             reduce using rule 111 (dim_star -> .)
    AND             reduce using rule 111 (dim_star -> .)
    OR              reduce using rule 111 (dim_star -> .)
    SEMICOLON       reduce using rule 111 (dim_star -> .)
    COMMA           reduce using rule 111 (dim_star -> .)
    RBRACKET        reduce using rule 111 (dim_star -> .)

    dim_star                       shift and go to state 193
    dim_expr                       shift and go to state 194

state 182

    (108) dim_expr_plus -> dim_expr .

    LBRACKET        reduce using rule 108 (dim_expr_plus -> dim_expr .)
    RPAREN          reduce using rule 108 (dim_expr_plus -> dim_expr .)
    PLUS            reduce using rule 108 (dim_expr_plus -> dim_expr .)
    REMAIN          reduce using rule 108 (dim_expr_plus -> dim_expr .)
    MINUS           reduce using rule 108 (dim_expr_plus -> dim_expr .)
    MULTIPLY        reduce using rule 108 (dim_expr_plus -> dim_expr .)
    DIVIDE          reduce using rule 108 (dim_expr_plus -> dim_expr .)
    EQ              reduce using rule 108 (dim_expr_plus -> dim_expr .)
    NEQ             reduce using rule 108 (dim_expr_plus -> dim_expr .)
    LT              reduce using rule 108 (dim_expr_plus -> dim_expr .)
    LEQ             reduce using rule 108 (dim_expr_plus -> dim_expr .)
    GT              reduce using rule 108 (dim_expr_plus -> dim_expr .)
    GEQ             reduce using rule 108 (dim_expr_plus -> dim_expr .)
    AND             reduce using rule 108 (dim_expr_plus -> dim_expr .)
    OR              reduce using rule 108 (dim_expr_plus -> dim_expr .)
    SEMICOLON       reduce using rule 108 (dim_expr_plus -> dim_expr .)
    COMMA           reduce using rule 108 (dim_expr_plus -> dim_expr .)
    RBRACKET        reduce using rule 108 (dim_expr_plus -> dim_expr .)


state 183

    (109) dim_expr -> LBRACKET . expr RBRACKET
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 196
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 184

    (49) stmt -> WHILE LPAREN expr RPAREN . stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . IF LPAREN expr RPAREN stmt
    (49) stmt -> . WHILE LPAREN expr RPAREN stmt
    (50) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (51) stmt -> . RETURN LPAREN expr_opt RPAREN SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (58) stmt -> . error SEMICOLON
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE
    (26) var_decl -> . type var_list SEMICOLON
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    IF              shift and go to state 72
    WHILE           shift and go to state 74
    FOR             shift and go to state 75
    RETURN          shift and go to state 77
    BREAK           shift and go to state 79
    CONTINUE        shift and go to state 80
    SEMICOLON       shift and go to state 76
    error           shift and go to state 192
    LBRACE          shift and go to state 60
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 90
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt                           shift and go to state 197
    stmt_expr                      shift and go to state 78
    block                          shift and go to state 81
    var_decl                       shift and go to state 82
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    type                           shift and go to state 85
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 185

    (50) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON . expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (116) expr_opt -> . expr
    (117) expr_opt -> .
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    SEMICOLON       reduce using rule 117 (expr_opt -> .)
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr_opt                       shift and go to state 198
    expr                           shift and go to state 159
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 186

    (51) stmt -> RETURN LPAREN expr_opt RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 199


state 187

    (81) method_invocation -> field_access LPAREN args_opt RPAREN .

    SEMICOLON       reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    DOT             reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    LBRACKET        reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    RPAREN          reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    PLUS            reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    REMAIN          reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    MINUS           reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    MULTIPLY        reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    DIVIDE          reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    EQ              reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    NEQ             reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    LT              reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    LEQ             reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    GT              reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    GEQ             reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    AND             reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    OR              reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    COMMA           reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)
    RBRACKET        reduce using rule 81 (method_invocation -> field_access LPAREN args_opt RPAREN .)


state 188

    (74) arg_plus -> arg_plus COMMA . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 200
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 189

    (80) array_access -> primary LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    INC             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    DEC             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    DOT             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    REMAIN          reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    MULTIPLY        reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    EQ              reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    NEQ             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    LT              reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    LEQ             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    GT              reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    GEQ             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    AND             reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    OR              reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 80 (array_access -> primary LBRACKET expr RBRACKET .)


state 190

    (69) primary -> NEW ID LPAREN args_opt . RPAREN

    RPAREN          shift and go to state 201


state 191

    (47) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt
    (48) stmt -> IF LPAREN expr RPAREN stmt .

    error           reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    INC             reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    DEC             reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 48 (stmt -> IF LPAREN expr RPAREN stmt .)

  ! ELSE            [ shift and go to state 202 ]


state 192

    (58) stmt -> error . SEMICOLON

    SEMICOLON       shift and go to state 105


state 193

    (106) new_array -> NEW type dim_expr_plus dim_star .

    RPAREN          reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    PLUS            reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    REMAIN          reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    MINUS           reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    MULTIPLY        reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    DIVIDE          reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    EQ              reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    NEQ             reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    LT              reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    LEQ             reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    GT              reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    GEQ             reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    AND             reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    OR              reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    SEMICOLON       reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    COMMA           reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)
    RBRACKET        reduce using rule 106 (new_array -> NEW type dim_expr_plus dim_star .)


state 194

    (107) dim_expr_plus -> dim_expr_plus dim_expr .

    LBRACKET        reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    RPAREN          reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    PLUS            reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    REMAIN          reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    MINUS           reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    MULTIPLY        reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    DIVIDE          reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    EQ              reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    NEQ             reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    LT              reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    LEQ             reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    GT              reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    GEQ             reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    AND             reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    OR              reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    SEMICOLON       reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    COMMA           reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)
    RBRACKET        reduce using rule 107 (dim_expr_plus -> dim_expr_plus dim_expr .)


state 195

    (110) dim_star -> LBRACKET . RBRACKET dim_star
    (109) dim_expr -> LBRACKET . expr RBRACKET
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . new_array
    (85) expr -> . expr PLUS expr
    (86) expr -> . expr REMAIN expr
    (87) expr -> . expr MINUS expr
    (88) expr -> . expr MULTIPLY expr
    (89) expr -> . expr DIVIDE expr
    (90) expr -> . expr EQ expr
    (91) expr -> . expr NEQ expr
    (92) expr -> . expr LT expr
    (93) expr -> . expr LEQ expr
    (94) expr -> . expr GT expr
    (95) expr -> . expr GEQ expr
    (96) expr -> . expr AND expr
    (97) expr -> . expr OR expr
    (98) expr -> . PLUS expr
    (99) expr -> . MINUS expr
    (100) expr -> . NOT expr
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (106) new_array -> . NEW type dim_expr_plus dim_star
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET

    RBRACKET        shift and go to state 56
    PLUS            shift and go to state 111
    MINUS           shift and go to state 112
    NOT             shift and go to state 113
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 114
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 115

    expr                           shift and go to state 196
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    new_array                      shift and go to state 110
    literal                        shift and go to state 93
    lhs                            shift and go to state 116
    method_invocation              shift and go to state 117
    field_access                   shift and go to state 118
    array_access                   shift and go to state 91

state 196

    (109) dim_expr -> LBRACKET expr . RBRACKET
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    RBRACKET        shift and go to state 203
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 197

    (49) stmt -> WHILE LPAREN expr RPAREN stmt .

    error           reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INC             reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    DEC             reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 49 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 198

    (50) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt . SEMICOLON stmt_expr_opt RPAREN stmt

    SEMICOLON       shift and go to state 204


state 199

    (51) stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .

    error           reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    IF              reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    INC             reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    DEC             reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    INT             reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    ID              reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    THIS            reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    SUPER           reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    NEW             reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    INT_CONST       reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    FLOAT_CONST     reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    STRING_CONST    reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    NULL            reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> RETURN LPAREN expr_opt RPAREN SEMICOLON .)


state 200

    (74) arg_plus -> arg_plus COMMA expr .
    (85) expr -> expr . PLUS expr
    (86) expr -> expr . REMAIN expr
    (87) expr -> expr . MINUS expr
    (88) expr -> expr . MULTIPLY expr
    (89) expr -> expr . DIVIDE expr
    (90) expr -> expr . EQ expr
    (91) expr -> expr . NEQ expr
    (92) expr -> expr . LT expr
    (93) expr -> expr . LEQ expr
    (94) expr -> expr . GT expr
    (95) expr -> expr . GEQ expr
    (96) expr -> expr . AND expr
    (97) expr -> expr . OR expr

    COMMA           reduce using rule 74 (arg_plus -> arg_plus COMMA expr .)
    RPAREN          reduce using rule 74 (arg_plus -> arg_plus COMMA expr .)
    PLUS            shift and go to state 137
    REMAIN          shift and go to state 138
    MINUS           shift and go to state 139
    MULTIPLY        shift and go to state 140
    DIVIDE          shift and go to state 141
    EQ              shift and go to state 142
    NEQ             shift and go to state 143
    LT              shift and go to state 144
    LEQ             shift and go to state 145
    GT              shift and go to state 146
    GEQ             shift and go to state 147
    AND             shift and go to state 148
    OR              shift and go to state 149


state 201

    (69) primary -> NEW ID LPAREN args_opt RPAREN .

    DOT             reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    LBRACKET        reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    RPAREN          reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    PLUS            reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    REMAIN          reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    MINUS           reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    MULTIPLY        reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    DIVIDE          reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    EQ              reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    NEQ             reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    LT              reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    LEQ             reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    GT              reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    GEQ             reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    AND             reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    OR              reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    SEMICOLON       reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    COMMA           reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)
    RBRACKET        reduce using rule 69 (primary -> NEW ID LPAREN args_opt RPAREN .)


state 202

    (47) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . IF LPAREN expr RPAREN stmt
    (49) stmt -> . WHILE LPAREN expr RPAREN stmt
    (50) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (51) stmt -> . RETURN LPAREN expr_opt RPAREN SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (58) stmt -> . error SEMICOLON
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE
    (26) var_decl -> . type var_list SEMICOLON
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    IF              shift and go to state 72
    WHILE           shift and go to state 74
    FOR             shift and go to state 75
    RETURN          shift and go to state 77
    BREAK           shift and go to state 79
    CONTINUE        shift and go to state 80
    SEMICOLON       shift and go to state 76
    error           shift and go to state 192
    LBRACE          shift and go to state 60
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 90
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt                           shift and go to state 205
    stmt_expr                      shift and go to state 78
    block                          shift and go to state 81
    var_decl                       shift and go to state 82
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    type                           shift and go to state 85
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 203

    (109) dim_expr -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    REMAIN          reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    MULTIPLY        reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    EQ              reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    NEQ             reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    LT              reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    LEQ             reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    GT              reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    GEQ             reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    AND             reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    OR              reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 109 (dim_expr -> LBRACKET expr RBRACKET .)


state 204

    (50) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON . stmt_expr_opt RPAREN stmt
    (114) stmt_expr_opt -> . stmt_expr
    (115) stmt_expr_opt -> .
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    RPAREN          reduce using rule 115 (stmt_expr_opt -> .)
    INC             shift and go to state 87
    DEC             shift and go to state 88
    ID              shift and go to state 115
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt_expr_opt                  shift and go to state 206
    stmt_expr                      shift and go to state 157
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 205

    (47) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    error           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INC             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DEC             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT_CONST       reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT_CONST     reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRING_CONST    reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 206

    (50) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt . RPAREN stmt

    RPAREN          shift and go to state 207


state 207

    (50) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN . stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . IF LPAREN expr RPAREN stmt
    (49) stmt -> . WHILE LPAREN expr RPAREN stmt
    (50) stmt -> . FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt
    (51) stmt -> . RETURN LPAREN expr_opt RPAREN SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl
    (57) stmt -> . SEMICOLON
    (58) stmt -> . error SEMICOLON
    (112) stmt_expr -> . assign
    (113) stmt_expr -> . method_invocation
    (41) block -> . LBRACE block_begin stmt_list block_end RBRACE
    (42) block -> . LBRACE block_begin stmt_list error block_end RBRACE
    (26) var_decl -> . type var_list SEMICOLON
    (101) assign -> . lhs ASSIGN expr
    (102) assign -> . lhs INC
    (103) assign -> . INC lhs
    (104) assign -> . lhs DEC
    (105) assign -> . DEC lhs
    (81) method_invocation -> . field_access LPAREN args_opt RPAREN
    (27) type -> . INT
    (28) type -> . BOOLEAN
    (29) type -> . FLOAT
    (30) type -> . ID
    (76) lhs -> . field_access
    (77) lhs -> . array_access
    (78) field_access -> . primary DOT ID
    (79) field_access -> . ID
    (80) array_access -> . primary LBRACKET expr RBRACKET
    (65) primary -> . literal
    (66) primary -> . THIS
    (67) primary -> . SUPER
    (68) primary -> . LPAREN expr RPAREN
    (69) primary -> . NEW ID LPAREN args_opt RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (59) literal -> . INT_CONST
    (60) literal -> . FLOAT_CONST
    (61) literal -> . STRING_CONST
    (62) literal -> . NULL
    (63) literal -> . TRUE
    (64) literal -> . FALSE

    IF              shift and go to state 72
    WHILE           shift and go to state 74
    FOR             shift and go to state 75
    RETURN          shift and go to state 77
    BREAK           shift and go to state 79
    CONTINUE        shift and go to state 80
    SEMICOLON       shift and go to state 76
    error           shift and go to state 192
    LBRACE          shift and go to state 60
    INC             shift and go to state 87
    DEC             shift and go to state 88
    INT             shift and go to state 30
    BOOLEAN         shift and go to state 31
    FLOAT           shift and go to state 32
    ID              shift and go to state 90
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LPAREN          shift and go to state 73
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt                           shift and go to state 208
    stmt_expr                      shift and go to state 78
    block                          shift and go to state 81
    var_decl                       shift and go to state 82
    assign                         shift and go to state 83
    method_invocation              shift and go to state 84
    type                           shift and go to state 85
    lhs                            shift and go to state 86
    field_access                   shift and go to state 89
    array_access                   shift and go to state 91
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 208

    (50) stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .

    error           reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    IF              reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    WHILE           reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FOR             reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    RETURN          reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    BREAK           reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    CONTINUE        reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    SEMICOLON       reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    LBRACE          reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    INC             reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    DEC             reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    INT             reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    BOOLEAN         reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FLOAT           reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    ID              reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    THIS            reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    SUPER           reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    LPAREN          reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    NEW             reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    INT_CONST       reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FLOAT_CONST     reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    STRING_CONST    reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    NULL            reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    TRUE            reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    FALSE           reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    RBRACE          reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)
    ELSE            reduce using rule 50 (stmt -> FOR LPAREN stmt_expr_opt SEMICOLON expr_opt SEMICOLON stmt_expr_opt RPAREN stmt .)

